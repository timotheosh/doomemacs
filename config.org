#+title: Emacs Config (Doom Emacs)
#+author: Tim Hawes
#+property: header-args :tangle yes :mkdirp yes

* Headings
** Packages File
Create the packages.el file.
#+BEGIN_SRC emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

#+END_SRC
* Identification
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Tim Hawes"
      user-mail-address "trhawes@gmail.com"
      github-account-name "timotheosh")
#+END_SRC
* Global
#+BEGIN_SRC emacs-lisp
;;(remove-hook 'doom-first-buffer-hook #'smartparens-global-mode)
(setq! show-paren-mode 1
       doom-scratch-initial-major-mode t)
(setq! auth-sources '("~/.authinfo.gpg"))
#+END_SRC
* Appearance
** Fonts
Doom exposes five (optional) variables for controlling fonts in Doom. Here are the three important ones:
- ~doom-font~
- ~doom-variable-pitch-font~
- ~doom-big-font~ -- used for ~doom-big-font-mode~ Use this for presentations or streaming.
They all accept either a font-spec, font string ("Input Mono-12"), or xlfd font string. You generally only need these two:
#+BEGIN_SRC emacs-lisp
;;(setq doom-font (font-spec :family "Iosevka Term" :size 18))
(setq doom-font (font-spec :family "Roboto Mono" :size 14))
;;(setq doom-variable-pitch-font (font-spec :family "Roboto Mono" :size 18))
#+END_SRC
** Theme
There are two ways to load a theme. Both assume the theme is installed and available. You can either set ~doom-theme~ or manually load a theme with the ~load-theme~ function. This is the default:
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-one)
#+END_SRC
** Set Banner
#+BEGIN_SRC emacs-lisp
(setq fancy-splash-image
      (concat doom-private-dir "banners/" "emacs-pen-3d.png"))
#+END_SRC
** Line number style
This determines the style of line numbers in effect. If set to `nil', line numbers are disabled. For relative line numbers, set this to `relative'.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC
* Key Maps
** Centaur Tabs
#+BEGIN_SRC emacs-lisp
(map! :map centaur-tabs-mode-map
      :g "C-<prior>" #'centaur-tabs-backward
      :g "C-<next>" #'centaur-tabs-forward)
#+END_SRC
** Projectile hotkeys
#+BEGIN_SRC emacs-lisp
(map! :map projectile-mode-map
      :g "<f4>" #'projectile-find-file)
#+END_SRC
** Return counsel-find-file back to its default behavior
#+BEGIN_SRC emacs-lisp
(after! ivy
  (map! :map ivy-minibuffer-map
        :g "TAB" #'ivy-partial))
(after! counsel
  (map! :map counsel-M-x-map
        :g "TAB" #'ivy-partial))
#+END_SRC
* Additional Modules
** Swiper
Better isearch replacement
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! swiper)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(map! "C-s" #'swiper)
#+END_SRC
** Smex
Useful for showing recent choices.
#+BEGIN_SRC emacs-list :tangle packages.el
(package! smex)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package! smex
  :init
  (smex-initialize))
#+END_SRC
** [[https://github.com/lastquestion/explain-pause-mode][explain-pause-mode]]
explain-pause-mode is very lightweight; you can leave it running all the time. You can check the buffer ~*explain-pause-log*~ to see what was slow and the information gathered.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! explain-pause-mode :recipe (:host github :repo "lastquestion/explain-pause-mode"))
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;(explain-pause-mode t)
#+END_SRC
* Additional Macros
Here are some additional functions/macros that could help you configure Doom:
- ~load!~ for loading external *.el files relative to this one
- ~use-package~ for configuring packages
- ~after!~ for running code after a package has loaded
- ~add-load-path!~ for adding directories to the `load-path', relative to this file. Emacs searches the ~load-path~ when you load packages with ~require~ or ~use-package~.
- ~map!~ for binding new keys

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press 'K' (non-evil users must press 'C-c g k'). This will open documentation for it, including demos of how they are used.

You can also try 'gd' (or 'C-c g d') to jump to their definition and see how they are implemented.
* My Functions/Macros
This will kill the buffer and return back to the last buffer visited, when you stop running a program in a terminal.
#+BEGIN_SRC emacs-lisp
;;(defadvice term-handle-exit
;;    (after term-kill-buffer-on-exit activate)
;;  (kill-buffer)
;;  (switch-to-buffer (car (car (window-prev-buffers)))))
#+END_SRC
These are some convenience functions for programs I run often.
#+BEGIN_SRC emacs-lisp
;; Function for determining the Linux distribution (if it is Linux)
;; Return system-type, unless system-type is gnu/linux, then
;;  return the output of lsb_release if available.
(defun system-distribution()
  (if (and (string= system-type "gnu/linux")
           (executable-find "lsb_release"))
      (replace-regexp-in-string ;; NixOS echos extraneous quotes in lsb_release
       "\\W" ""
       (car (split-string (shell-command-to-string "lsb_release -sd"))))
    system-type))
(setq system-distro (system-distribution))

(defun multi-term-program (program)
  "Make a multi-term buffer running program."
  (let ((multi-term-program program))
    (multi-term)))

(defun aptitude ()
  "Run Aptitude"
    (interactive)
    (multi-term-program "aptitude"))

(defun htop ()
  "Run Htop"
  (interactive)
  (multi-term-program "htop"))

(defun neofetch ()
  (interactive)
  (ansi-term "neofetch"))
#+END_SRC
* Run program
This is for running arbitrary programs I don't run often.
#+BEGIN_SRC emacs-lisp
(use-package! dired)
(defun run-program (input)
  (interactive
   (list (read-shell-command "run command: ")))
  (let ((cmd (split-string input)))
    (dired-start-process (car cmd) (cdr cmd))))

(map! "C-!" #'run-program)
#+END_SRC
* Emacs Frame Manager
The purpose of this module is managing Emacs windows in an environment without using EXWM. This will offer functions an emacsclient can run conditioned on the current state of the window, and fast terminal access within Emacs. This will work with X11, not sure what the implications are for Cocoa or Windows.
** Frame Names
First, we set up unique names for the X Window names, so we can easily reference these windows in an X Window environment. The names have random numbers, to make them easier to isolate among many windows in an X environment.
   #+BEGIN_SRC emacs-lisp
(defvar efm/frame-name "emacs-frame-manager998")
(defvar efm/shell-name "emacs-frame-manager336")
(defvar efm/org-name "emacs-frame-manager920")
   #+END_SRC
** Default buffer
The default buffer to load.
#+BEGIN_SRC emacs-lisp
(setq efm/default-buffer "*doom*")
#+END_SRC
** Extra frames
When emacs runs in daemon mode under systemd, emacsclient can, and sometimes will, create extra frames when you execute a command with emacsclient that does not need a frame, before any frames have been opened, and then execute emacsclient with a new frame. We keep track of legitimate frames, so we can just delete the unneeded frames. If you add new frames above that you intend to use, be sure to add them to this list, so they do not get inadvertently deleted.
   #+BEGIN_SRC emacs-lisp
(defvar efm/legit-frames (list efm/frame-name efm/shell-name efm/org-name "F1"))
   #+END_SRC
- Now the utility functions
  #+BEGIN_SRC emacs-lisp
(defun efm/list-illegite-frames ()
  "Lists visible illegitimate frames. Essentially all frames not in the efm/legit-frames list and is visible."
  (remove-if
   (lambda (x)
     (seq-find (lambda (y)
                 (string= y
                          (frame-parameter x 'name))) efm/legit-frames))
   (remove-if-not 'frame-visible-p (frame-list))))

(defun efm/kill-illegite-frames ()
  "Deletes the extra visible frames."
  (dolist (buf (efm/list-illegite-frames))
    (delete-frame buf)))
  #+END_SRC
** Frame management
Utility functions for frame management. These find frames, suspend frames, raise frames and maximize frames.
#+BEGIN_SRC emacs-lisp

(defun efm/find-frame (frame-name)
  "Returns a list of frames with frame-name."
  (remove-if-not
   (lambda (x)
     (string= (frame-parameter x 'name) frame-name))
   (frame-list)))

(defun efm/maximized-p (frame)
  "Returns true if frame is maximized or fullboth."
  (cdr (assoc 'fullscreen (frame-parameters frame))))

(defun efm/create-frame (frame-name frame-title)
  "Creates a maximized frame, raised and in focus."
  (make-frame-on-display (getenv "DISPLAY") `((name . ,frame-name)
                                              (title . ,frame-title)
                                              (fullscreen . maximized)
                                              (window-system . x)))
  (let ((frame (car (efm/find-frame name))))
    (frame-focus frame)
    (x-focus-frame frame)))

(defun efm/raise-frame (frame)
  "Raises a frame and puts it in focus."
  (raise-frame frame)
  (select-frame frame)
  (x-focus-frame frame))

(defun efm/frame-focus-maximize (frame &optional command)
  "Raise, focus, and maximize a frame."
  (efm/raise-frame frame)
  (modify-frame-parameters frame '((fullscreen . maximized)))
  (when command
    (eval (list (intern command)))))

(defun efm/run-command (command)
  (cond ((string-equal command default-buffer) (switch-to-buffer efm/default-buffer))
        ((string-equal command "doom-buffer") (+doom-dashboard/open (car (efm/find-frame efm/frame-name))))))

(defun efm/start-client-with-command (name title &optional command skip-taskbar)
  "Create a new frame, executing command."
  (efm/create-frame name title)
  (if command
      (eval (list (intern command)))
    (efm/run-command "doom-buffer"))
  (when skip-taskbar
    (modify-frame-parameters (car (efm/find-frame name)) '((skip-taskbar t)
                                                           (undecorated t)))))

(defun efm/raise-or-start (name title &optional command toggle skip-taskbar)
  "If frame with name does not exist, create it, otherwise raise, focus and maximize the existing frame."
  (let ((frame (car (efm/find-frame name))))
    (if frame
        (if (and (frame-focus-state frame)
                 (efm/maximized-p frame)
                 (or (and (null command) (null toggle))
                     (and (not (null command)) (not (null toggle)))))
            (progn (select-frame frame)
                   (suspend-frame))
          (efm/frame-focus-maximize frame command))
      (efm/start-client-with-command name title command skip-taskbar))))

#+END_SRC
* Applications
** Email
Use Gmail in gnus
*** Settings
#+BEGIN_SRC emacs-lisp
(setq!
 send-mail-function 'smtpmail-send-it
 message-send-mail-function 'smtpmail-send-it
 user-mail-address "trhawes@gmail.com"
 smtpmail-starttls-credentials '(("smtp.gmail.com" "587" nil nil))
 smtpmail-auth-credentials (expand-file-name "~/.authinfo")
 smtpmail-default-smtp-server "smtp.gmail.com"
 smtpmail-smtp-server "smtp.gmail.com"
 smtpmail-smtp-service 587
 smtpmail-debug-info t
 starttls-extra-arguments nil
 starttls-gnutls-program "/usr/bin/gnutls-cli"
 starttls-extra-arguments nil
 starttls-use-gnutls t
 )
#+END_SRC
** Web browser
*** Settings
#+BEGIN_SRC emacs-lisp
(setq! browse-url-generic-program "/usr/local/bin/next")
(setq! browse-url-default-browser 'eww-browse-url)
;;(setq shr-external-browser 'browse-url-generic)
(setq!
 browse-url-browser-function
 '(
   ("youtube\\.com" . browse-url-generic)
   ("vimeo\\.com" . browse-url-generic)
   ("facebook\\.com" . browse-url-firefox)
   ("reddit\\.com" . browse-url-firefox)
   ("." . eww-browse-url)))
#+END_SRC
* Pcomplete
** apt
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-apt-commands
  '("autoclean" "clean" "full-upgrade" "policy" "show"
    "autopurge" "depends" "help" "purge" "showsrc"
    "autoremove" "dist-upgrade" "install" "rdepends" "source"
    "build-dep" "download" "list" "remove" "update"
    "changelog" "edit-sources" "moo" "search" "upgrade"))
(defun pcomplete/apt ()
  (pcomplete-here* pcmpl-apt-commands))
#+END_SRC
** apt-get
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-apt-get-commands
  '("autoclean" "check" "dselect-upgrade" "remove"
    "autoremove" "clean" "indextargets" "source" "moo"
    "build-dep" "dist-upgrade" "install" "update"
    "changelog" "download" "purge" "upgrade"))
(defun pcomplete/apt-get ()
  (pcomplete-here* pcmpl-apt-get-commands))
#+END_SRC
** exercism
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-exercism-commands
  '("configure" "help" "submit" "upgrade" "workspace"
    "download" "open" "troubleshoot" "version")
  "List of `exercism' commands")
(defun pcomplete/exercism ()
  (pcomplete-here* pcmpl-exercism-commands))
#+END_SRC
** git
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-git-commands
  '("add" "bisect" "branch" "checkout" "clone"
    "commit" "diff" "fetch" "grep"
    "init" "log" "merge" "mv" "pull" "push" "rebase"
    "reset" "rm" "show" "status" "tag" )
  "List of `git' commands")

(defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
  "The `git' command to run to get a list of refs")

(defun pcmpl-git-get-refs (type)
  "Return a list of `git' refs filtered by TYPE"
  (with-temp-buffer
    (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
    (goto-char (point-min))
    (let ((ref-list))
      (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
        (add-to-list 'ref-list (match-string 1)))
      ref-list)))

(defun pcomplete/git ()
  "Completion for `git'"
  ;; Completion for the command argument.
  (pcomplete-here* pcmpl-git-commands)
  ;; complete files/dirs forever if the command is `add' or `rm'
  (cond
   ((pcomplete-match (regexp-opt '("add" "rm")) 1)
    (while (pcomplete-here (pcomplete-entries))))
   ;; provide branch completion for the command `checkout'.
   ((pcomplete-match "checkout" 1)
    (pcomplete-here* (pcmpl-git-get-refs "heads")))))
#+END_SRC
* Dired
** Settings
#+BEGIN_SRC emacs-lisp
(setq! dired-hide-details-mode t)
(setq! ranger-override-dired-mode t)
#+END_SRC
** Functions
#+BEGIN_SRC emacs-lisp
;; Dired code taken from https://oremacs.com/2015/01/04/dired-nohup/
;; This incorporates nohup with starting a process
(after! dired
  (use-package! dired-aux)

  (defvar dired-filelist-cmd
    '(("vlc" "-L")))

  (defun dired-start-process (cmd &optional file-list)
    (interactive
     (let ((files (dired-get-marked-files
                   t current-prefix-arg)))
       (list
        (dired-read-shell-command "& on %s: "
                                  current-prefix-arg files)
        files)))
    (let (list-switch)
      (start-process
       cmd nil shell-file-name
       shell-command-switch
       (format
        "nohup 1>/dev/null 2>/dev/null %s \"%s\""
        (if (and (> (length file-list) 1)
                 (setq list-switch
                       (cadr (assoc cmd dired-filelist-cmd))))
            (format "%s %s" cmd list-switch)
          cmd)
        (mapconcat #'expand-file-name file-list "\" \""))))))
#+END_SRC
* Shells
** Multi-vterm
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! multi-vterm)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(when (string= system-distro "NixOS")
  (let ((emacs-path (concat (getenv "HOME") "/.nix-profile/share/emacs/site-lisp/elpa/vterm-20200107.1419")))
    (add-to-list 'load-path emacs-path)
    (load! (concat emacs-path "/vterm.el")))

(after! vterm
  (use-package! multi-vterm)
  (map! "C-M-<right>" 'multi-vterm-next
          "C-M-<left>" 'multi-vterm-prev))
;;(defalias 'multi-term 'multi-vterm)
#+END_SRC
** Eshell
*** Packages
**** [[https://github.com/tom-tan/esh-help][esh-help]] for Eshell help
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! fish-completion :disable t)
(package! esh-help)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! eshell
  (use-package! esh-help)
  (setup-esh-help-eldoc))
#+END_SRC
**** [[https://github.com/emacsmirror/multi-eshell][Multiple eshell]] Original blog seems to be missing, but available on marmalade.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! multi-eshell)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package! multi-eshell)
#+END_SRC
**** [[https://github.com/porterjamesj/virtualenvwrapper.el][Virtualenvwrapper]] for Emacs
[[https://virtualenvwrapper.readthedocs.io/en/latest/][Virtualenvwrapper]] is a set of extensions for more easily managing multiple virtualenv's for Python. It is available on Debian and Ubuntu systems. This is an Emacs module that interfaces with that system, making it easy to use in Eshell and Emacs proper.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! virtualenvwrapper)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package! virtualenvwrapper)
(setq! venv-location "~/.virtualenvs/")
#+END_SRC
*** Settings
**** Directory path for eshell-directory-name
#+BEGIN_SRC emacs-lisp
(after! eshell-z
  (setq! eshell-directory-name (concat doom-private-dir "eshell")))
#+END_SRC
**** Custom magit commands in eshell
#+BEGIN_SRC emacs-lisp
(after! eshell
  (defun eshell/mgit (&rest args)
    "Using magit in eshell"
    (eshell-eval-using-options
     "mgit" args
     '((?s "status" nil status "Show git status for repo.")
       (?l "log" nil log "Show git log for all branches")
       (nil "help" nil nil "Show this usage information")
       :show-usage)
     (eshell-do-eval
      (eshell-parse-command
       (cond
        (status "magit-status")
        (log "magit-log-all-branches")))
      t))))
#+END_SRC
**** Custom dpkg commands in eshell
#+BEGIN_SRC emacs-lisp
(after! eshell
  (defun eshell/deb (&rest args)
    "deb command for eshell"
    (eshell-eval-using-options
     "deb" args
     '((?f "find" t find "list available packages matching a pattern")
       (?i "installed" t installed "list installed debs matching a pattern")
       (?l "list-files" t list-files "list files of a package")
       (?s "show" t show "show an available package")
       (?v "version" t version "show the version of an installed package")
       (?w "where" t where "find the package containing the given file")
       (nil "help" nil nil "show this usage information")
       :show-usage)
     (eshell-do-eval
      (eshell-parse-command
       (cond
        (find
         (format "apt-cache search %s" find))
        (installed
         (format "dlocate -l %s | grep '^.i'" installed))
        (list-files
         (format "dlocate -L %s | sort" list-files))
        (show
         (format "apt-cache show %s" show))
        (version
         (format "dlocate -s %s | egrep '^(Package|Status|Version):'" version))
        (where
         (format "dlocate %s" where))))
      t))))
#+END_SRC
**** Eshell history settings
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq eshell-history-size 1024)

  ; So the history vars are defined
  (load "em-hist")

  ;; Don't ask, just save
  ;;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
  (if (boundp 'eshell-save-history-on-exit)
      (setq eshell-save-history-on-exit t))

  ;; For older(?) version
  ;;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
  (if (boundp 'eshell-ask-to-save-history)
      (setq eshell-ask-to-save-history 'always))
)
#+END_SRC
**** Tramp settings for eshell
#+BEGIN_SRC emacs-lisp
(after! eshell
  (use-package! esh-module)) ;; load tramp functions into eshell
#+END_SRC
**** Custom prompt
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! eshell-prompt-extras)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! eshell
  (use-package! eshell-prompt-extras
    :config
    ;; for virtualenvwrapper stuff
    (with-eval-after-load "esh-opt"
      (require 'virtualenvwrapper)
      (venv-initialize-eshell)
      (autoload 'epe-theme-lambda "eshell-prompt-extras")
      (setq eshell-highlight-prompt nil
            eshell-prompt-function 'epe-theme-lambda
            eshell-prompt-regexp "^[^#\nλ]*[#λ] "
            epe-show-python-info t
            epe-path-style 'single))))
#+END_SRC
*** Modules
#+BEGIN_SRC emacs-lisp
(after! eshell
  (add-to-list 'eshell-modules-list 'eshell-tramp 'esh-opt))
#+END_SRC
*** Preferred functions and variables
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq eshell-prefer-lisp-functions t)
  (setq eshell-prefer-lisp-variables t))
#+END_SRC
*** Password caching
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 300)) ; for 5 minutes (time in secs)
#+END_SRC
*** Progress bar for apt in minibuffer
#+BEGIN_SRC emacs-lisp
;; Progress bars, like apt in the status/echo area
(after! eshell
  (advice-add
   'ansi-color-apply-on-region
   :before 'ora-ansi-color-apply-on-region)

  (defun ora-ansi-color-apply-on-region (begin end)
    "Fix progress bars for e.g. apt(8).
     Display progress in the mode line instead."
    (let ((end-marker (copy-marker end))
          mb)
      (save-excursion
        (goto-char (copy-marker begin))
        (while (re-search-forward "\0337" end-marker t)
          (setq mb (match-beginning 0))
          (when (re-search-forward "\0338" end-marker t)
            (ora-apt-progress-message
             (substring-no-properties
              (delete-and-extract-region mb (point))
              2 -2)))))))

  (defun ora-apt-progress-message (progress)
    (message
     (replace-regexp-in-string
      "%" "%%"
      (ansi-color-apply progress))))
)
#+END_SRC
*** Visual commands
#+BEGIN_SRC emacs-lisp
;; Visual commands
;; defaults are ("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm")
(after! eshell
  (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm"))
  (dolist (cmd '("tmux" "aptitude" "aws-shell" "neofetch" "htop" "radeontop"))
    (add-to-list 'eshell-visual-commands cmd)))
#+END_SRC
*** Use Emacs completion package for Eshell
#+BEGIN_SRC emacs-lisp
;; Uses the default Emacs completion package for tab-complete in eshell.
;;(after! eshell
;;  (add-hook! 'eshell-mode-hook
;;            (lambda ()
;;              (define-key eshell-mode-map (kbd "<tab>")
;;                (lambda () (interactive) (pcomplete-std-complete))))))
#+END_SRC
** Shell-pop
#+BEGIN_SRC emacs-lisp
(map! "<f3>" '+eshell/toggle)
#+END_SRC
* Deft
#+BEGIN_SRC emacs-lisp
(setq! deft-extensions '("org" "md" "txt" "tex"))
(setq! deft-directory "~/Dropbox/notes")
(setq! deft-recursive t)
(map! "<f8>" 'deft)
#+END_SRC
* Org-mode
** Org files location
If you use `org' and don't want your org files in the default location below, change `org-directory'. It must be set before org loads!
#+BEGIN_SRC emacs-lisp
(setq! org-directory "~/org")
#+END_SRC
** Basic Config
#+BEGIN_SRC emacs-lisp
(setq! org-startup-folded t)
#+END_SRC
** Keymap for org-mode
#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        :g (kbd "<C-down-mouse-1>") #'org-open-at-point))
#+END_SRC
** Org modules
*** Github Flavored Markdown
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! ox-gfm)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! ox-gfm))
#+END_SRC
*** Pretty bullets
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-bullets)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-bullets
  :config
  (add-hook! 'org-mode-hook #'org-bullets-mode)))
#+END_SRC
*** Convert org to OpenOffice
#+BEGIN_SRC emacs-lisp
(use-package! ox-odt)
#+END_SRC
*** Inline Racket
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! ob-racket :recipe (:host github :repo "wallyqs/ob-racket"))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! ob-racket))
#+END_SRC
*** Jira
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-jira)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-jira
    :init
    (setq! jiralib-url "https://inindca.atlassian.net"
           org-jira-working-dir (concat
                                  (if (boundp 'doom-private-dir)
                                      doom-private-dir
                                    user-emacs-directory) "jira")))
  (when (not (file-directory-p org-jira-working-dir))
    (make-directory org-jira-working-dir)))
#+END_SRC
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-projectile)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-projectile
    :bind (("C-c n p" . org-projectile-project-todo-completing-read)
           ("C-c c" . org-capture))
    :config
    (if (string= system-name "scholasticus")
        (setq! org-projectile-projects-file
               "~/org/GTD/work/code-projects.org")
      (setq! org-projectile-projects-file
             "~/org/GTD/home/code-projects.org"))
    (setq! org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (push (org-projectile-project-todo-entry) org-capture-templates)))
#+END_SRC
*** org2blog
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org2blog)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org2blog
    :config
    (setq! org2blog/wp-blog-alist
           '(("timhawes"
              :url "https://timhawes.wordpress.com/xmlrpc.php"
              :username "timotheosh")))))
#+END_SRC
*** org-protocol
#+BEGIN_SRC emacs-lisp
;;(use-package! org-protocol)
#+END_SRC
*** Agenda files
#+BEGIN_SRC emacs-lisp
(if (string= system-name "scholasticus")
    (setq! org-agenda-files (file-expand-wildcards "~/org/GTD/work/*.org"))
  (setq! org-agenda-files (file-expand-wildcards "~/org/GTD/home/*.org")))
#+END_SRC
*** Templates
#+BEGIN_SRC emacs-lisp

#+END_SRC
*** Settings
#+BEGIN_SRC emacs-lisp
(add-hook! 'org-mode-hook
           #'visual-line-mode
           #'org-indent-mode)
#+END_SRC
*** obtt
obtt is an acronym for "org-babel-tangle templates".
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! obtt :recipe (:host github :repo "timotheosh/obtt"))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! obtt
    :init
    (setq! obtt-templates-dir (concat
                                  (if (boundp 'doom-private-dir)
                                      doom-private-dir
                                    user-emacs-directory) "obtt")
           obtt-seed-name ".obtt")))
(when (not (file-directory-p obtt-templates-dir))
    (make-directory obtt-templates-dir))
#+END_SRC
** Org-Roam
#+BEGIN_SRC emacs-lisp
(let ((roam-dir "~/org/roam"))
  (when (not (file-exists-p roam-dir))
    (make-directory roam-dir))
  (setq! org-roam-directory roam-dir))
(add-hook! 'after-init-hook 'org-roam-mode)
(use-package! org-roam-protocol)
(after! org-roam
  (setq! org-roam-capture-templates
         '(("d" "default" plain #'org-roam-capture--get-point
            "%?"
            :file-name "%<%Y%m%d%H%M%S>-${slug}"
            :head "#+TITLE: ${title}"
            "%i"
            :unnarrowed t))))
#+END_SRC
* RSS Reader
Settings for Elfeed rss feed reader
#+BEGIN_SRC emacs-lisp
(after! elfeed
  (use-package! elfeed
    :config
    (setq elfeed-feeds
          '(("http://www.garynorth.com/mysite.xml" economics)
            ("http://feeds.fee.org/FEE-Freeman" economics)
            ("https://www.eff.org/rss" technology politics)
            ("https://emacsredux.com/feed.xml" blog emacs)
            ("http://emacsrocks.com/atom.xml" blog emacs)
            ("http://pragmaticemacs.com/feed/" blog emacs)
            ("https://stackoverflow.com/feeds/tag?tagnames=emacs&sort=newest" stackoverflow emacs)
            ("https://www.reddit.com/r/emacs.rss" reddit technology emacs)
            ("https://www.reddit.com/r/lisp.rss" reddit technology lisp)
            ("https://www.reddit.com/r/clojure.rss" reddit technology lisp clojure)
            ("https://www.reddit.com/r/Racket.rss" reddit technology lisp racket)
            ("https://stevelosh.com/rss.xml" blog technology lisp)
            ("http://planet.lisp.org/rss20.xml" blog technology lisp)
            ("https://lispblog.xach.com/rss" blog technology lisp)
            ("https://lispnews.wordpress.com/rss.xml" blog technology lisp)
            ("https://borretti.me/feed.xml" blog technology)
            ("https://stackoverflow.com/feeds/tag?tagnames=common-lisp&sort=newest" stackoverflow lisp)
            ("https://planet.kde.org/global/atom.xml/" blog desktop kde)
            ("https://www.kdevelop.org/rss.xml" blog desktop kde kdevelop)))))
#+END_SRC
* Programming Languages
** General
*** Settings
**** [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] for better formatting of code.
Just ~(add-hook! /programming-mode-hook/ #'aggressive-indent-mode)~ to activate.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! aggressive-indent)
#+END_SRC
**** [[https://github.com/company-mode/company-quickhelp][Company-quickhelp]] for on the fly documentation.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! company-quickhelp)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! company
  (setq! company-quickhelp-delay nil))
(map! :map company-active-map
      :g "C-c h" #'company-quickhelp-manual-begin)
#+END_SRC
**** Code folding
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! origami)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (use-package! origami
    :bind (("C-<tab>" . origami-recursively-toggle-node)
           ("C-<iso-lefttab>" . origami-toggle-all-nodes))
    :hook 'prog-mode-hook))
#+END_SRC
**** Smartparens for paredit functionality is many different programming language modes
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (use-package! smartparens-config
    :config
    ;; For lisp modes
    (sp-with-modes sp--lisp-modes
      ;; disable ', it's the quote character!
      (sp-local-pair "'" nil :actions nil)
      ;; also only use the pseudo-quote inside strings where it serve as
      ;; hyperlink.
      (sp-local-pair "`" "'" :when '(sp-in-string-p sp-in-comment-p))
      (sp-local-pair "`" nil
                     :skip-match
                     (lambda (ms mb me)
                       (cond
                        ((equal ms "'")
                         (or (sp--org-skip-markup ms mb me)
                             (not (sp-point-in-string-or-comment))))
                        (t (not (sp-point-in-string-or-comment)))))))
    (sp-with-modes 'org-mode
      (sp-local-pair "\\[" "\\]")
      (sp-local-pair "$" "$")
      (sp-local-pair "'" "'" :actions '(rem))
      (sp-local-pair "=" "=" :actions '(rem))
      (sp-local-pair "\\left(" "\\right)" :trigger "\\l(" :post-handlers '(sp-latex-insert-spaces-inside-pair))
      (sp-local-pair "\\left[" "\\right]" :trigger "\\l[" :post-handlers '(sp-latex-insert-spaces-inside-pair))
      (sp-local-pair "\\left\\{" "\\right\\}" :trigger "\\l{" :post-handlers '(sp-latex-insert-spaces-inside-pair))
      (sp-local-pair "\\left|" "\\right|" :trigger "\\l|" :post-handlers '(sp-latex-insert-spaces-inside-pair)))))
#+END_SRC
**** Match parenthesis/brackets
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (defun my/match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert normally."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1))))))
(map! :map prog-mode-map
      :g "<backtab>" 'my/match-paren)
#+END_SRC
**** Lisp extra fontlock
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! lisp-extra-font-lock)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! prog-mode (use-package! lisp-extra-font-lock))
#+END_SRC
** Common Lisp
*** Settings
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (use-package! aggressive-indent)
  (use-package! company-quickhelp)
  (add-hook! 'lisp-mode-hook
             #'smartparens-strict-mode
             #'aggressive-indent-mode
             #'lisp-extra-font-lock-mode
             #'company-quickhelp-mode)
  (after! sly
    (setq! sly-lisp-implementations
           '((sbcl ("~/programs/bin/ros" "-L" "sbcl" "-Q" "run") :coding-system utf-8-unix)
             (clisp ("~/programs/bin/ros" "-L" "clisp" "-Q" "run"))
             (clozure-cl ("~/programs/bin/ros" "-L" "ccl-bin" "-Q" "run"))
             (cmucl ("~/programs/bin/ros" "-L" "cmu-bin" "-Q" "run"))
             (ecl ("~/programs/bin/ros" "-L" "ecl" "-Q" "run") :coding-system utf-8-unix)
             (abcl ("~/programs/bin/ros" "-L" "abcl-bin" "-Q" "run"))))
    (add-hook! 'sly-mrepl-hook #'company-quickhelp-mode)))
#+END_SRC
**** Hyperspec lookup
Open CL REPL and execute: ~(ql:quickload "clhs")~, then follow instructions.
~C-c C-d h~ on common lisp directive, and it should open the definition in the default web browser.
#+BEGIN_SRC emacs-lisp
(after! lisp-mode
  (when (file-exists-p "/home/thawes/.roswell/lisp/quicklisp/clhs-use-local.el")
    (load! "/home/thawes/.roswell/lisp/quicklisp/clhs-use-local.el")))
(map! :after sly
      :map lisp-mode-map
      :g "C-c C-d h" #'sly-documentation-lookup)
#+END_SRC
**** Common Lisp Language Server
This is functional, but untested on Doom Emacs, and disabled for now. Most of the functionality for this is given with Sly/Slime.

In order to use, be sure to install the language server first, by running ~ros install cxxxr/cl-lsp~
See also the Github repo [[https://github.com/cxxxr/cl-lsp.git][cl-lsp]].
#+BEGIN_SRC emacs-lisp
;; (add-to-list 'lsp-language-id-configuration '(lisp-mode "lisp"))
;;   (lsp-register-client
;;    (make-lsp-client :new-connection (lsp-stdio-connection "cl-lsp")
;;                     :major-modes '(lisp-mode)
;;                     :server-id 'cl-lsp))
;;   (add-hook 'lisp-mode-hook 'lsp-deferred)
#+END_SRC
** Emacs Lisp
*** Settings
#+BEGIN_SRC emacs-lisp
(after! emacs-lisp
  (add-to-list 'company-backends 'company-elisp))
(add-hook! 'emacs-lisp-mode-hook
           #'eldoc-mode
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode
           #'company-quickhelp-mode)
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! auto-virtualenv)
(package! anaconda-mode :ignore t)
(package! python-mode)
(package! jedi)
(package! pydoc)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! python
  (use-package! auto-virtualenv)
  (use-package! jedi
    :commands jedi:setup)
  (use-package! lsp-pyls)
  (use-package! pydoc
    :config
    (map! :map 'python-mode-map
          :g "C-c C-h" #'pydoc-at-point))
  (add-hook! 'python-mode-hook
             #'auto-virtualenv-set-virtualenv
             #'lsp-deferred)
  (setq! py-ipython-command-args '("--automagic" "--simple-prompt")
         jedi:complete-on-dot t)
  (map! :map 'python-mode-map
        :g "C-c C-c" #'py-execute-buffer-ipython))
#+END_SRC
**
** Clojure
#+BEGIN_SRC emacs-lisp
(add-hook! 'clojure-mode-hook #'lsp-deferred)
(add-hook! 'clojurescript-mode-hook #'lsp-deferred)
#+END_SRC
** HTML
*** Impatience mode for realtime editing of html
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
;;(package! impatient-mode :recipe '(:host github :repo "skeeto/impatient-mode"))
(package! impatient-mode)
#+END_SRC
**** Hooks
#+BEGIN_SRC emacs-lisp
(add-hook! 'mhtml-mode-hook #'impatient-mode)
(add-hook! 'css-mode-hook #'impatient-mode)
#+END_SRC

#+RESULTS:
| impatient-mode | doom--enable-+javascript-npm-mode-in-css-mode-h |

** Javascript
*** Websocket
Needed by Indium
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! websocket :recipe
  '(:host github :repo "ahyatt/emacs-websocket")
  :pin "491a60b")
#+END_SRC
*** Indium
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! indium :recipe
  '(:host github :repo "NicolasPetton/Indium")
  :pin "9614d63")
#+END_SRC
**** Configuration
#+BEGIN_SRC emacs-lisp
(after! js2-mode
  (use-package! websocket)
  (use-package! indium))
#+END_SRC
