#+title: Emacs Config (Doom Emacs)
#+author: Tim Hawes
#+property: header-args :tangle yes :mkdirp yes

* Headings
** Packages File
Create the packages.el file.
#+BEGIN_SRC emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

#+END_SRC
* Identification
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Tim Hawes"
      user-mail-address "trhawes@gmail.com"
      github-account-name "timotheosh")
#+END_SRC
* Global
** Disable global smartparens-mode
Smartparens is awesome, but we don't want it everywhere.
#+BEGIN_SRC emacs-lisp
(remove-hook 'doom-first-buffer-hook #'smartparens-global-mode)
(setq! show-paren-mode 1
       doom-scratch-initial-major-mode t)
(setq! auth-sources '("~/.authinfo.gpg"))
#+END_SRC
** Long lines
*** Bidirectional Editing
Disable bidirectional editing. NOTE: You'll need to change this if you decide to write someing in Hebrew or Chinese.
#+begin_src emacs-lisp
(setq-default bidi-paragraph-direction 'left-to-right)
#+end_src
*** Bidirectional parenthesis
Same applies from Bidirectional Editing above.
#+begin_src emacs-lisp
(if (version<= "27.1" emacs-version)
    (setq bidi-inhibit-bpa t))
#+end_src
*** So-long mode
Disable this and use ~find-file-literally~ instead, if you don't want this globally.
#+begin_src emacs-lisp
;;(if (version<= "27.1" emacs-version)
;;    (global-so-long-mode 1))
#+end_src
* Appearance
** Fonts
Doom exposes five (optional) variables for controlling fonts in Doom. Here are the three important ones:
- ~doom-font~
- ~doom-variable-pitch-font~
- ~doom-big-font~ -- used for ~doom-big-font-mode~ Use this for presentations or streaming.
They all accept either a font-spec, font string ("Input Mono-12"), or xlfd font string. You generally
only need these two:
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "Iosevka" :size 18))
;;(setq doom-variable-pitch-font (font-spec :family "ETBookOT"))
;;Mostly works
(setq doom-variable-pitch-font (font-spec :family "FreeSerif"))
#+END_SRC
** Mixed-pitch Fonts
*** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! mixed-pitch)
#+END_SRC
*** Config
#+BEGIN_SRC emacs-lisp
(setq! mixed-pitched-variable-pitch-cursor 'bar)
#+END_SRC
** Olivetti Mode
*** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! olivetti)
#+END_SRC
** Theme
There are two ways to load a theme. Both assume the theme is installed and available. You can either set ~doom-theme~ or manually load a theme with the ~load-theme~ function. This is the default:
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-one)
#+END_SRC
** Set Banner
#+BEGIN_SRC emacs-lisp
(setq fancy-splash-image
      (concat doom-private-dir "banners/" "emacs-pen-3d.png"))
#+END_SRC
** Line number style
This determines the style of line numbers in effect. If set to `nil', line numbers are disabled. For relative line numbers, set this to `relative'.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC
* Key Maps
** Global keys
~overwrite-mode~ in Emacs is a huge nuissasnce to me. It is a trap, not a feature. So disable its key.
#+begin_src emacs-lisp
(global-unset-key (kbd "<insert>"))
#+end_src
** Centaur Tabs
#+BEGIN_SRC emacs-lisp
(map! :map centaur-tabs-mode-map
      :g "C-<prior>" #'centaur-tabs-backward
      :g "C-<next>" #'centaur-tabs-forward)
#+END_SRC
** Return counsel-find-file back to its default behavior
#+BEGIN_SRC emacs-lisp
(after! ivy
  (map! :map ivy-minibuffer-map
        :g "TAB" #'ivy-partial))
(after! counsel
  (map! :map counsel-M-x-map
        :g "TAB" #'ivy-partial))
#+END_SRC
** Projectile-find-file
F4 gives us ~counsel-projectile-find-file~
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<F4>") 'counsel-projectile-find-file)
#+END_SRC
* Additional Modules
** Swiper
Better isearch replacement
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! swiper :recipe (:host github :repo "abo-abo/swiper") :pin "7c5d49f") ;; commit date: 2021/05/18
#+END_SRC
#+BEGIN_SRC emacs-lisp
(map! "C-s" #'swiper)
#+END_SRC
** [[https://github.com/lastquestion/explain-pause-mode][explain-pause-mode]]
explain-pause-mode is very lightweight; you can leave it running all the time. You can check the buffer ~*explain-pause-log*~ to see what was slow and the information gathered.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! explain-pause-mode :recipe
  (:host github :repo "lastquestion/explain-pause-mode") :pin "2356c8c") ;; commit date 2020/07/27
#+END_SRC
#+BEGIN_SRC emacs-lisp
;;(explain-pause-mode t)
#+END_SRC
** Spell-fu
*** Install
#+begin_src emacs-lisp :tangle packages.el
(package! spell-fu :recipe
  (:host gitlab :repo "ideasman42/emacs-spell-fu")
  :pin "fae15427") ; Commit date 2021/04/14
#+end_src
*** Config
#+begin_src emacs-lisp
(after! org-mode
  (add-hook 'org-mode-hook
            (lambda ()
              (setq spell-fu-faces-exclude '(org-meta-line org-link org-code))
              (spell-fu-mode))))
#+end_src
* Additional Macros
Here are some additional functions/macros that could help you configure Doom:
- ~load!~ for loading external *.el files relative to this one
- ~use-package~ for configuring packages
- ~after!~ for running code after a package has loaded
- ~add-load-path!~ for adding directories to the `load-path', relative to this file. Emacs searches the ~load-path~ when you load packages with ~require~ or ~use-package~.
- ~map!~ for binding new keys

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press 'K' (non-evil users must press 'C-c g k'). This will open documentation for it, including demos of how they are used.

You can also try 'gd' (or 'C-c g d') to jump to their definition and see how they are implemented.
* My Functions/Macros
** Terminal program ends
This will kill the buffer and return back to the last buffer visited, when you stop running a program in a terminal.
#+BEGIN_SRC emacs-lisp
;;(defadvice term-handle-exit
;;    (after term-kill-buffer-on-exit activate)
;;  (kill-buffer)
;;  (switch-to-buffer (car (car (window-prev-buffers)))))
#+END_SRC
** Programs I run
These are some convenience functions for programs I run often.
#+BEGIN_SRC emacs-lisp
(defun system-distribution()
  (if (and (string= system-type "gnu/linux")
           (executable-find "lsb_release"))
      (replace-regexp-in-string ;; NixOS echos extraneous quotes in lsb_release
       "\\W" ""
       (car (split-string (shell-command-to-string "lsb_release -sd"))))
    system-type))
(setq! system-distro (system-distribution))

(use-package! multi-term
  :config
  ;; These have functions only work, once we have loaded multi-term
  (defun trh/run-term-program (program)
    "Make a multi-term buffer running program."
    (let ((multi-term-program program))
      (multi-term)))

  (defun aptitude ()
    "Run Aptitude"
    (interactive)
    (trh/run-term-program "aptitude"))

  (defun htop ()
    "Run Htop"
    (interactive)
    (trh/run-term-program "htop"))

  (defun neofetch ()
    (interactive)
    (ansi-term "neofetch")))
#+END_SRC
** Disable line numbers function
#+BEGIN_SRC emacs-lisp
(defun disable-line-numbers ()
  (display-line-numbers-mode -1))
#+END_SRC
** Functions for xdg desktop environment
#+begin_src emacs-lisp
(defun my/xdg-data-dirs ()
  "Returns a list of xdg-data-dirs. There's a similar function in counsel."
  (split-string (getenv "XDG_DATA_DIRS") ":"))

(defun my/find-soundfile (file)
  "Returns the path for a sound file if it is in xdg-data-dirs"
  (let ((xdg-path (car (seq-filter (lambda (x)
                                     (file-exists-p (concat x "/sounds/" file)))
                                   (my/xdg-data-dirs)))))
    (when xdg-path
      (concat xdg-path "/sounds/" file))))
#+end_src
* Run program
This is for running arbitrary programs I don't run often.
#+BEGIN_SRC emacs-lisp
(defun run-program (input)
  (interactive
   (list (read-shell-command "run command: ")))
  (let ((cmd (split-string input)))
    (dired-start-process (car cmd) (cdr cmd))))

(map! "C-!" #'run-program)
#+END_SRC
* Emacs Frame Manager
The purpose of this module is managing Emacs windows in an environment without using EXWM. This will offer functions an emacsclient can run conditioned on the current state of the window, and fast terminal access within Emacs. This will work with X11, not sure what the implications are for Cocoa or Windows.
** Frame Names
First, we set up unique names for the X Window names, so we can easily reference these windows in an X Window environment. The names have random numbers, to make them easier to isolate among many windows in an X environment.
   #+BEGIN_SRC emacs-lisp
(defvar efm/frame-name "emacs-frame-manager998")
(defvar efm/shell-name "emacs-frame-manager336")
(defvar efm/org-name "emacs-frame-manager920")
   #+END_SRC
** Default buffer
The default buffer to load.
#+BEGIN_SRC emacs-lisp
(setq efm/default-buffer "*doom*")
#+END_SRC
** Extra frames
When emacs runs in daemon mode under systemd, emacsclient can, and sometimes will, create extra frames when you execute a command with emacsclient that does not need a frame, before any frames have been opened, and then execute emacsclient with a new frame. We keep track of legitimate frames, so we can just delete the unneeded frames. If you add new frames above that you intend to use, be sure to add them to this list, so they do not get inadvertently deleted.
   #+BEGIN_SRC emacs-lisp
(defvar efm/legit-frames (list efm/frame-name efm/shell-name efm/org-name "F1"))
   #+END_SRC
- Now the utility functions
  #+BEGIN_SRC emacs-lisp
(defun efm/list-illegite-frames ()
  "Lists visible illegitimate frames. Essentially all frames not in the efm/legit-frames list and is visible."
  (cl-remove-if
   (lambda (x)
     (seq-find (lambda (y)
                 (string= y
                          (frame-parameter x 'name))) efm/legit-frames))
   (cl-remove-if-not 'frame-visible-p (frame-list))))

(defun efm/kill-illegite-frames ()
  "Deletes the extra visible frames."
  (dolist (buf (efm/list-illegite-frames))
    (delete-frame buf)))
  #+END_SRC
** Frame management
Utility functions for frame management. These find frames, suspend frames, raise frames and maximize frames.
#+BEGIN_SRC emacs-lisp

(defun efm/find-frame (frame-name)
  "Returns a list of frames with frame-name."
  (cl-remove-if-not
   (lambda (x)
     (string= (frame-parameter x 'name) frame-name))
   (frame-list)))

(defun efm/maximized-p (frame)
  "Returns true if frame is maximized or fullboth."
  (cdr (assoc 'fullscreen (frame-parameters frame))))

(defun efm/create-frame (frame-name frame-title)
  "Creates a maximized frame, raised and in focus."
  (make-frame-on-display (getenv "DISPLAY") `((name . ,frame-name)
                                              (title . ,frame-title)
                                              (fullscreen . maximized)
                                              (window-system . x)))
  (let ((frame (car (efm/find-frame frame-name))))
    (frame-focus frame)
    (x-focus-frame frame)))

(defun efm/raise-frame (frame)
  "Raises a frame and puts it in focus."
  (raise-frame frame)
  (select-frame frame)
  (x-focus-frame frame))

(defun efm/frame-focus-maximize (frame &optional command)
  "Raise, focus, and maximize a frame."
  (efm/raise-frame frame)
  (modify-frame-parameters frame '((fullscreen . maximized)))
  (when command
    (eval (list (intern command)))))

(defun efm/run-command (command)
  (cond ((string-equal command default-buffer) (switch-to-buffer efm/default-buffer))
        ((string-equal command "doom-buffer") (+doom-dashboard/open (car (efm/find-frame efm/frame-name))))))

(defun efm/start-client-with-command (name title &optional command skip-taskbar)
  "Create a new frame, executing command."
  (efm/create-frame name title)
  (if command
      (eval (list (intern command)))
    (efm/run-command "doom-buffer"))
  (when skip-taskbar
    (modify-frame-parameters (car (efm/find-frame name))
                             '((skip-taskbar t)
                               (undecorated t)))))

(defun efm/raise-or-start (name title &optional command toggle skip-taskbar)
  "If frame with name does not exist, create it, otherwise raise, focus and maximize the existing frame."
  (let ((frame (car (efm/find-frame name))))
    (if frame
        (if (and (frame-focus-state frame)
                 (efm/maximized-p frame)
                 (or (and (null command) (null toggle))
                     (and (not (null command)) (not (null toggle)))))
            (progn (select-frame frame)
                   (suspend-frame))
          (efm/frame-focus-maximize frame command))
      (efm/start-client-with-command name title command skip-taskbar))))

#+END_SRC
* Applications
** Email
Use Gmail in gnus
*** Settings
#+BEGIN_SRC emacs-lisp
(setq!
 send-mail-function 'smtpmail-send-it
 message-send-mail-function 'smtpmail-send-it
 user-mail-address "trhawes@gmail.com"
 smtpmail-starttls-credentials '(("smtp.gmail.com" "587" nil nil))
 smtpmail-auth-credentials (expand-file-name "~/.authinfo")
 smtpmail-default-smtp-server "smtp.gmail.com"
 smtpmail-smtp-server "smtp.gmail.com"
 smtpmail-smtp-service 587
 smtpmail-debug-info t
 starttls-extra-arguments nil
 starttls-gnutls-program "/usr/bin/gnutls-cli"
 starttls-extra-arguments nil
 starttls-use-gnutls t
 )
#+END_SRC
** Web browser
*** Settings
#+BEGIN_SRC emacs-lisp
(setq! browse-url-generic-program "/usr/bin/nyxt")
(setq! browse-url-default-browser 'eww-browse-url)
;;(setq shr-external-browser 'browse-url-generic)
(setq!
 browse-url-browser-function
 '(
   ("youtube\\.com" . browse-url-generic)
   ("vimeo\\.com" . browse-url-generic)
   ("facebook\\.com" . browse-url-firefox)
   ("reddit\\.com" . browse-url-firefox)
   ("." . eww-browse-url)))
#+END_SRC
** Search Tools
*** Google
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! google-this)
#+END_SRC
**** Config
Default mapping is "C-c / t"
#+BEGIN_SRC emacs-lisp
(google-this-mode 1)
#+END_SRC
** UUID
Allows you to generate a UUID in a writable buffer, with ~M-x uuidgen~.
*** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! uuidgen :recipe
  (:host github :repo "kanru/uuidgen-el")
  :pin "b50e6fe") ;; Commit date 2020/08/16
#+END_SRC
** Magit
*** Settings
**** git path
Because nix is now installing git from my package choices, I need to make sure my system git is preferred. I will need to change for nonstandard git installs.
#+begin_src emacs-lisp
(let ((git-path (split-string (executable-find "git") "/")))
  (when (member ".nix-profile" git-path)
    (cond
     ((file-executable-p "/usr/bin/git") (setq! magit-git-executable "/usr/bin/git"))
     ((file-executable-p "/user/local/bin/git") (setq! magit-git-executable "/usr/local/bin/git"))
     ((file-executable-p "/usr/pkg/bin/git") (setq! magit-git-executable "/usr/pkg/bin/git"))
     (t "default"))))
#+end_src
* Pcomplete
** apt
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-apt-commands
  '("autoclean" "clean" "full-upgrade" "policy" "show"
    "autopurge" "depends" "help" "purge" "showsrc"
    "autoremove" "dist-upgrade" "install" "rdepends" "source"
    "build-dep" "download" "list" "remove" "update"
    "changelog" "edit-sources" "moo" "search" "upgrade"))
(defun pcomplete/apt ()
  (pcomplete-here* pcmpl-apt-commands))
#+END_SRC
** apt-get
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-apt-get-commands
  '("autoclean" "check" "dselect-upgrade" "remove"
    "autoremove" "clean" "indextargets" "source" "moo"
    "build-dep" "dist-upgrade" "install" "update"
    "changelog" "download" "purge" "upgrade"))
(defun pcomplete/apt-get ()
  (pcomplete-here* pcmpl-apt-get-commands))
#+END_SRC
** exercism
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-exercism-commands
  '("configure" "help" "submit" "upgrade" "workspace"
    "download" "open" "troubleshoot" "version")
  "List of `exercism' commands")
(defun pcomplete/exercism ()
  (pcomplete-here* pcmpl-exercism-commands))
#+END_SRC
** git
#+BEGIN_SRC emacs-lisp
(defconst pcmpl-git-commands
  '("add" "bisect" "branch" "checkout" "clone"
    "commit" "diff" "fetch" "grep"
    "init" "log" "merge" "mv" "pull" "push" "rebase"
    "reset" "rm" "show" "status" "tag" )
  "List of `git' commands")

(defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
  "The `git' command to run to get a list of refs")

(defun pcmpl-git-get-refs (type)
  "Return a list of `git' refs filtered by TYPE"
  (with-temp-buffer
    (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
    (goto-char (point-min))
    (let ((ref-list))
      (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
        (add-to-list 'ref-list (match-string 1)))
      ref-list)))

(defun pcomplete/git ()
  "Completion for `git'"
  ;; Completion for the command argument.
  (pcomplete-here* pcmpl-git-commands)
  ;; complete files/dirs forever if the command is `add' or `rm'
  (cond
   ((pcomplete-match (regexp-opt '("add" "rm")) 1)
    (while (pcomplete-here (pcomplete-entries))))
   ;; provide branch completion for the command `checkout'.
   ((pcomplete-match "checkout" 1)
    (pcomplete-here* (pcmpl-git-get-refs "heads")))))
#+END_SRC
* Dired
** Settings
#+BEGIN_SRC emacs-lisp
(setq! dired-hide-details-mode t)
(setq! ranger-override-dired-mode t)
#+END_SRC
** Functions
#+BEGIN_SRC emacs-lisp
;; Dired code taken from https://oremacs.com/2015/01/04/dired-nohup/
;; This incorporates nohup with starting a process
(after! dired
  (use-package! dired-aux)

  (defvar dired-filelist-cmd
    '(("vlc" "-L")))

  (defun dired-start-process (cmd &optional file-list)
    (interactive
     (let ((files (dired-get-marked-files
                   t current-prefix-arg)))
       (list
        (dired-read-shell-command "& on %s: "
                                  current-prefix-arg files)
        files)))
    (let (list-switch)
      (start-process
       cmd nil shell-file-name
       shell-command-switch
       (format
        "nohup 1>/dev/null 2>/dev/null %s \"%s\""
        (if (and (> (length file-list) 1)
                 (setq list-switch
                       (cadr (assoc cmd dired-filelist-cmd))))
            (format "%s %s" cmd list-switch)
          cmd)
        (mapconcat #'expand-file-name file-list "\" \""))))))
#+END_SRC
* Shells
** Eshell
*** Packages
**** [[https://github.com/tom-tan/esh-help][esh-help]] for Eshell help
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! fish-completion :disable t)
(package! esh-help :recipe
  (:host github :repo "tom-tan/esh-help") :pin "417673e") ;;Commit date 2019/9/4
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setup-esh-help-eldoc))
#+END_SRC
**** [[https://github.com/emacsmirror/multi-eshell][Multiple eshell]] Original blog seems to be missing, but available on marmalade.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! multi-eshell)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(use-package! multi-eshell)
#+END_SRC
**** [[https://github.com/porterjamesj/virtualenvwrapper.el][Virtualenvwrapper]] for Emacs
[[https://virtualenvwrapper.readthedocs.io/en/latest/][Virtualenvwrapper]] is a set of extensions for more easily managing multiple virtualenv's for Python. It is available on Debian and Ubuntu systems. This is an Emacs module that interfaces with that system, making it easy to use in Eshell and Emacs proper.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! virtualenvwrapper :recipe
  (:host github :repo "porterjamesj/virtualenvwrapper.el")
  :pin "c7e8450") ;; Commit date 2021/4/7
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! virtualenvwrapper
  (setq! venv-location "~/.virtualenvs/"))
#+END_SRC
*** Settings
**** Directory path for eshell-directory-name
#+BEGIN_SRC emacs-lisp
(after! eshell-z
  (setq! eshell-directory-name (concat doom-private-dir "eshell"))
  (setq! eshell-aliases-file (concat doom-private-dir "eshell/alias")))
#+END_SRC
**** Custom magit commands in eshell
#+BEGIN_SRC emacs-lisp
(after! eshell
  (defun eshell/mgit (&rest args)
    "Using magit in eshell"
    (eshell-eval-using-options
     "mgit" args
     '((?s "status" nil status "Show git status for repo.")
       (?l "log" nil log "Show git log for all branches")
       (nil "help" nil nil "Show this usage information")
       :show-usage)
     (eshell-do-eval
      (eshell-parse-command
       (cond
        (status "magit-status")
        (log "magit-log-all-branches")))
      t))))
#+END_SRC
**** Custom dpkg commands in eshell
#+BEGIN_SRC emacs-lisp
(after! eshell
  (defun eshell/deb (&rest args)
    "deb command for eshell"
    (eshell-eval-using-options
     "deb" args
     '((?f "find" t find "list available packages matching a pattern")
       (?i "installed" t installed "list installed debs matching a pattern")
       (?l "list-files" t list-files "list files of a package")
       (?s "show" t show "show an available package")
       (?v "version" t version "show the version of an installed package")
       (?w "where" t where "find the package containing the given file")
       (nil "help" nil nil "show this usage information")
       :show-usage)
     (eshell-do-eval
      (eshell-parse-command
       (cond
        (find
         (format "apt-cache search %s" find))
        (installed
         (format "dlocate -l %s | grep '^.i'" installed))
        (list-files
         (format "dlocate -L %s | sort" list-files))
        (show
         (format "apt-cache show %s" show))
        (version
         (format "dlocate -s %s | egrep '^(Package|Status|Version):'" version))
        (where
         (format "dlocate %s" where))))
      t))))
#+END_SRC
**** Eshell history settings
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq eshell-history-size 1024)

  ; So the history vars are defined
  (load "em-hist")

  ;; Don't ask, just save
  ;;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
  (if (boundp 'eshell-save-history-on-exit)
      (setq eshell-save-history-on-exit t))

  ;; For older(?) version
  ;;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
  (if (boundp 'eshell-ask-to-save-history)
      (setq eshell-ask-to-save-history 'always))
)
#+END_SRC
**** Custom prompt
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! eshell-prompt-extras :recipe
  (:host github :repo "zwild/eshell-prompt-extras")
  :pin "d7d874c") ;;Commit date 2020/11/14
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! eshell
  (use-package! eshell-prompt-extras
    :config
    ;; for virtualenvwrapper stuff
    (with-eval-after-load "esh-opt"
      (require 'virtualenvwrapper)
      (venv-initialize-eshell)
      (autoload 'epe-theme-lambda "eshell-prompt-extras")
      (setq eshell-highlight-prompt nil
            eshell-prompt-function 'epe-theme-lambda
            eshell-prompt-regexp "^[^#\nλ]*[#λ] "
            epe-show-python-info t
            epe-path-style 'single))))
#+END_SRC
*** Modules
#+BEGIN_SRC emacs-lisp
(after! eshell
  (add-to-list 'eshell-modules-list 'eshell-tramp 'esh-opt))
#+END_SRC
*** Preferred functions and variables
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq eshell-prefer-lisp-functions t)
  (setq eshell-prefer-lisp-variables t))
#+END_SRC
*** Password caching
#+BEGIN_SRC emacs-lisp
(after! eshell
  (setq password-cache t) ; enable password caching
  (setq password-cache-expiry 300)) ; for 5 minutes (time in secs)
#+END_SRC
*** Progress bar for apt in minibuffer
#+BEGIN_SRC emacs-lisp
;; Progress bars, like apt in the status/echo area
(after! eshell
  (advice-add
   'ansi-color-apply-on-region
   :before 'ora-ansi-color-apply-on-region)

  (defun ora-ansi-color-apply-on-region (begin end)
    "Fix progress bars for e.g. apt(8).
     Display progress in the mode line instead."
    (let ((end-marker (copy-marker end))
          mb)
      (save-excursion
        (goto-char (copy-marker begin))
        (while (re-search-forward "\0337" end-marker t)
          (setq mb (match-beginning 0))
          (when (re-search-forward "\0338" end-marker t)
            (ora-apt-progress-message
             (substring-no-properties
              (delete-and-extract-region mb (point))
              2 -2)))))))

  (defun ora-apt-progress-message (progress)
    (message
     (replace-regexp-in-string
      "%" "%%"
      (ansi-color-apply progress))))
)
#+END_SRC
*** Visual commands
#+BEGIN_SRC emacs-lisp
;; Visual commands
;; defaults are ("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm")
(after! eshell
  (setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm"))
  (dolist (cmd '("tmux" "aptitude" "aws-shell" "neofetch" "htop" "radeontop"))
    (add-to-list 'eshell-visual-commands cmd)))
#+END_SRC
** Shell-pop
#+BEGIN_SRC emacs-lisp
(map! "<f3>" '+eshell/toggle)
#+END_SRC
* Deft
#+BEGIN_SRC emacs-lisp
(setq! deft-extensions '("org" "md" "txt" "tex"))
(setq! deft-directory "~/org-files/deft")
(setq! deft-recursive t)
(map! "<f8>" 'deft)
#+END_SRC
* Org-mode
** Org files location
If you use `org' and don't want your org files in the default location below, change `org-directory'. It must be set before org loads!
#+BEGIN_SRC emacs-lisp
(setq! org-directory "~/org-files")
#+END_SRC
** Basic Config
*** Variables
**** For all
#+begin_src emacs-lisp
(setq! org-startup-folded t
       org-hide-emphasis-markers t)
#+end_src
**** Separate org-work from org-home
#+begin_src emacs-lisp
(if (string= system-name "scholasticus")
    (setq! org-directory "~/org-files/GTD/work"
           org-agenda-files (file-expand-wildcards "~/org/GTD/work/*.org"))
  (setq org-directory "~/org-files/GTD/home"
        org-agenda-files (file-expand-wildcards "~/org/GTD/home/*.org")))
#+end_src
*** Hooks
#+BEGIN_SRC emacs-lisp
(add-hook! 'org-mode-hook
           #'disable-line-numbers
           #'org-indent-mode
           #'mixed-pitch-mode)
#+END_SRC
*** Keymap for org-mode
#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        :g (kbd "<C-down-mouse-1>") #'org-open-at-point))
#+END_SRC
** Jira
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-jira :recipe
  (:host github :repo "ahungry/org-jira")
  :pin "2136470") ;; Commit date 2021/5/14
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-jira
    :init
    (setq! jiralib-url "https://inindca.atlassian.net"
           org-jira-working-dir (concat
                                  (if (boundp 'doom-private-dir)
                                      doom-private-dir
                                    user-emacs-directory) "jira")))
  (when (not (file-directory-p org-jira-working-dir))
    (make-directory org-jira-working-dir)))
#+END_SRC
** Org modules
*** Convert to BBCode
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! ox-bb :recipe
  (:host github
   :repo "timotheosh/ox-bb"
   :branch "world-anvil-bbcode"))
#+end_src
**** Config
#+begin_src emacs-lisp
(after! org
  (use-package! ox-bb))
#+end_src
*** Github Flavored Markdown
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! ox-gfm)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! ox-gfm))
#+END_SRC
*** Pretty bullets
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-bullets)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-bullets
  :config
  (add-hook! 'org-mode-hook #'org-bullets-mode)))
#+END_SRC
*** Convert org to OpenOffice
**** Config
#+BEGIN_SRC emacs-lisp
(use-package! ox-odt)
#+END_SRC
*** Convert to revealjs
**** package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-reveal :recipe (:host github :repo "yjwen/org-reveal"))
#+END_SRC
**** config
#+BEGIN_SRC emacs-lisp
(add-hook! org-mode-hook #'ox-reveal
  (use-package! ox-reveal))
#+END_SRC
*** Inline Racket
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! ob-racket :recipe
  (:host github :repo "hasu/emacs-ob-racket")
  :pin "da3526c") ;; Commit date 2021/3/4
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! ob-racket))
#+END_SRC
*** Ansible
#+begin_src emacs-lisp :tangle packages.el
(package! ob-ansible :recipe
  (:host github :repo "timotheosh/ob-ansible")
  :pin "a95914c") ;; Commit date 2017/8/18
#+end_src
#+begin_src emacs-lisp
(after! org
  (use-package! ob-ansible))
#+end_src
*** Projectile
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org-projectile :recipe
  (:host github :repo "IvanMalison/org-projectile")
  :pin "96a57a4")
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org-projectile
    :bind (("C-c n p" . org-projectile-project-todo-completing-read)
           ("C-c c" . org-capture))
    :config
    (if (string= system-name "scholasticus")
        (setq! org-projectile-projects-file
               "~/org/GTD/work/code-projects.org")
      (setq! org-projectile-projects-file
             "~/org/GTD/home/code-projects.org"))
    (setq! org-agenda-files (append org-agenda-files (org-projectile-todo-files)))
    (push (org-projectile-project-todo-entry) org-capture-templates)))
#+END_SRC
*** org2blog
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! org2blog :recipe
  (:host github :repo "org2blog/org2blog")
  :pin "c1b386f") ;; Commit date 2021/4/21
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! org
  (use-package! org2blog
    :config
    (setq! org2blog/wp-blog-alist
           '(("timhawes"
              :url "https://timhawes.wordpress.com/xmlrpc.php"
              :username "timotheosh")))))
#+END_SRC
*** org-protocol
#+BEGIN_SRC emacs-lisp
;;(use-package! org-protocol)
#+END_SRC
*** obtt
obtt is an acronym for "org-babel-tangle templates".
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! obtt :recipe
  (:host github :repo "timotheosh/obtt")
  :pin "0285efb") ;; Commit date 2020/6/23
#+END_SRC
#+BEGIN_SRC emacs-lisp
(setq! obtt-templates-dir (concat
                              (if (boundp 'doom-private-dir)
                                  doom-private-dir
                                user-emacs-directory) "obtt")
       obtt-seed-name ".obtt")
(after! org
  (use-package! obtt))
(when (not (file-directory-p obtt-templates-dir))
    (make-directory obtt-templates-dir))
#+END_SRC
* RSS Reader
Settings for Elfeed rss feed reader
#+BEGIN_SRC emacs-lisp
(setq! elfeed-feeds
       '(("http://www.garynorth.com/mysite.xml" economics)
         ("http://feeds.fee.org/FEE-Freeman" economics)
         ("https://www.eff.org/rss" technology politics)
         ("https://emacsredux.com/feed.xml" blog emacs)
         ("http://emacsrocks.com/atom.xml" blog emacs)
         ("http://pragmaticemacs.com/feed/" blog emacs)
         ("https://stackoverflow.com/feeds/tag?tagnames=emacs&sort=newest" stackoverflow emacs)
         ("https://www.reddit.com/r/emacs.rss" reddit technology emacs)
         ("https://planet.emacslife.com/atom.xml" technology emacs)
         ("https://www.reddit.com/r/lisp.rss" reddit technology lisp)
         ("https://www.reddit.com/r/clojure.rss" reddit technology lisp clojure)
         ("https://www.reddit.com/r/Racket.rss" reddit technology lisp racket)
         ("https://stevelosh.com/rss.xml" blog technology lisp)
         ("http://planet.lisp.org/rss20.xml" blog technology lisp)
         ("https://lispblog.xach.com/rss" blog technology lisp)
         ("https://lispnews.wordpress.com/rss.xml" blog technology lisp)
         ("https://borretti.me/feed.xml" blog technology)
         ("https://stackoverflow.com/feeds/tag?tagnames=common-lisp&sort=newest" stackoverflow lisp)
         ("https://planet.kde.org/global/atom.xml/" blog desktop kde)
         ("https://www.kdevelop.org/rss.xml" blog desktop kde kdevelop)))

#+END_SRC
* Httpd Server
We use simple-httpd for emacs, since that comes with impatient-mode.
** Package
#+begin_src emacs-lisp :tangle packages.el
(package! simple-httpd :recipe
  (:host github :repo "skeeto/emacs-web-server")
  :pin "22ce66e") ;; Commit date 2019/11/3
#+end_src
* Programming Languages
** General
*** Settings
**** Safe variables for Projectile configurations
Predefining ahead of time. Each language can ~add-to-list~ to get their specific commands added.
#+begin_src emacs-lisp
(setq safe-local-variable-values '())
(setq enable-local-variables :all)
#+end_src
**** [[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] for better formatting of code.
Package should be explicitly added on a per programming language basis. It is especially effective with lisp languages.
***** Package
Just ~(add-hook! /programming-mode-hook/ #'aggressive-indent-mode)~ to activate.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! aggressive-indent :recipe
  (:host github :repo "Malabarba/aggressive-indent-mode")
  :pin "b0ec004") ;; Commit date 2020/8/24
#+END_SRC
**** [[https://github.com/company-mode/company-quickhelp][Company-quickhelp]] for on the fly documentation.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! company-quickhelp :recipe
  (:host github :repo "company-mode/company-quickhelp")
  :pin "530b293") ;; Commit date 2021/5/15
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! company
  (add-hook! 'company-mode-hook #'company-quickhelp-mode)
  (setq! company-quickhelp-delay nil))
(map! :map company-active-map
      :g "C-c h" #'company-quickhelp-manual-begin)
#+END_SRC
**** Code folding
Origami is a minor mode that enables code folding. Learn more [[https://github.com/gregsexton/origami.el][here]]. ~lsp-origami~ uses ~lsp~ to inform Origami. Learn more [[https://github.com/emacs-lsp/lsp-origami][here]].
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! origami :recipe
  (:host github :repo "gregsexton/origami.el")
  :pin "e558710") ;; Commit date 2020/3/31
(package! lsp-origami :recipe
  (:host github :repo "emacs-lsp/lsp-origami")
  :pin "bedea3d") ;; Commit date 2021/1/26
#+END_SRC
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (map! :map origami-mode-map
        (:g "C-<tab>" #'origami-recursively-toggle-node
         :g "C-<iso-lefttab>" #'origami-toggle-all-nodes))
  (add-hook! 'prog-mode-hook #'origami-mode)
  (add-hook! 'lsp-after-open-hook #'lsp-origami-try-enable))
#+END_SRC
**** Smartparens for paredit functionality is many different programming language modes
***** Config
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (sp-with-modes sp--lisp-modes
    ;; disable ', it's the quote character!
    (sp-local-pair "'" nil :actions nil)
    ;; also only use the pseudo-quote inside strings where it serve as
    ;; hyperlink.
    (sp-local-pair "`" "'" :when '(sp-in-string-p sp-in-comment-p))
    (sp-local-pair "`" nil
                   :skip-match
                   (lambda (ms mb me)
                     (cond
                      ((equal ms "'")
                       (or (sp--org-skip-markup ms mb me)
                           (not (sp-point-in-string-or-comment))))
                      (t (not (sp-point-in-string-or-comment))))))))
(after! org
  (sp-with-modes 'org-mode
    (sp-local-pair "\\[" "\\]")
    (sp-local-pair "$" "$")
    (sp-local-pair "'" "'" :actions '(rem))
    (sp-local-pair "=" "=" :actions '(rem))
    (sp-local-pair "\\left(" "\\right)" :trigger "\\l(" :post-handlers '(sp-latex-insert-spaces-inside-pair))
    (sp-local-pair "\\left[" "\\right]" :trigger "\\l[" :post-handlers '(sp-latex-insert-spaces-inside-pair))
    (sp-local-pair "\\left\\{" "\\right\\}" :trigger "\\l{" :post-handlers '(sp-latex-insert-spaces-inside-pair))
    (sp-local-pair "\\left|" "\\right|" :trigger "\\l|" :post-handlers '(sp-latex-insert-spaces-inside-pair))))
#+END_SRC
***** Key Bindings
#+begin_src emacs-lisp
(map! :map smartparens-mode-map
      (:g "C-M-a" #'sp-beginning-of-sexp
       :g "C-M-e" #'sp-end-of-sexp

       ;;:g "C-<down>" #'sp-down-sexp) ;; Conflicts with REPL bindings
       ;;:g "C-<up>"   #'sp-up-sexp)   ;; Conflicts with REPL bindings
       :g "M-<down>" #'sp-backward-down-sexp
       :g "M-<up>"   #'sp-backward-up-sexp

       :g "C-M-f" #'sp-forward-sexp
       :g "C-M-b" #'sp-backward-sexp

       :g "C-M-n" #'sp-next-sexp
       :g "C-M-p" #'sp-previous-sexp

       :g "C-S-f" #'sp-forward-symbol
       :g "C-S-b" #'sp-backward-symbol

       :g "C-<right>" #'sp-forward-slurp-sexp
       :g "M-<right>" #'sp-forward-barf-sexp
       :g "C-<left>"  #'sp-backward-slurp-sexp
       :g "M-<left>"  #'sp-backward-barf-sexp

       :g "C-M-t" #'sp-transpose-sexp
       :g "C-M-k" #'sp-kill-sexp
       :g "C-k"   #'sp-kill-hybrid-sexp
       :g "M-k"   #'sp-backward-kill-sexp
       :g "C-M-w" #'sp-copy-sexp

       :g "C-M-d" #'delete-sexp

       :g "M-<backspace>" #'backward-kill-word
       :g "C-<backspace>" #'sp-backward-kill-word
       :g [remap sp-backward-kill-word] #'backward-kill-word

       :g "M-[" #'sp-backward-unwrap-sexp
       :g "M-]" #'sp-unwrap-sexp

       :g "C-x C-t" #'sp-transpose-hybrid-sexp))
#+end_src
**** Match parenthesis/brackets
#+BEGIN_SRC emacs-lisp
(after! prog-mode
  (defun my/match-paren (arg)
    "Go to the matching paren if on a paren; otherwise insert normally."
    (interactive "p")
    (cond ((looking-at "\\s\(") (forward-list 1) (backward-char 1))
          ((looking-at "\\s\)") (forward-char 1) (backward-list 1))
          (t (self-insert-command (or arg 1)))))
  (map! :map prog-mode-map
        :g "<backtab>" 'my/match-paren))
#+END_SRC
**** Lisp extra fontlock
***** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! lisp-extra-font-lock :recipe
  (:host github :repo "Lindydancer/lisp-extra-font-lock")
  :pin "4605ecc") ;; Commit date 2018/10/8
#+END_SRC
** Emacs-epc
For talking with other languages. The main docs start [[https://github.com/kiwanami/emacs-epc][here]].
*** Package
#+begin_src emacs-lisp :tangle packages.el
(package! epc :recipe
  (:host github :repo "kiwanami/emacs-epc")
  :pin "e1bfa5c")
#+end_src
** Exercism.io
Personal project for projectile to understand exercism.io projects. The project is in [[https://github.com/timotheosh/exercism-mode][github]].
*** Package
#+begin_src emacs-lisp :tangle packages.el
;;(package! exercism-mode :recipe (:host github :repo "timotheosh/exercism-mode"))
#+end_src
*** Config
#+begin_src emacs-lisp
(use-package! exercism-mode
  :after projectile
  :load-path "~/src/projects/exercism-mode"
  :config (exercism-mode +1))
(map! :map exercism-mode-map
      :leader
      (:prefix ("x" . "Exercism")
       :desc "Submit current file"       "s" #'exercism-submit-file
       :desc "Download exercise"         "d" #'exercism-download-exercise
       :desc "Paste download command"    "p" #'exercism-download-command
       :desc "Refresh current exercise"  "r" #'exercism-refresh-exercise
       :desc "Open exercise description" "w" #'exercism-open-exercise-web))
(map! :map ranger-mode-map
      :leader
      (:prefix ("x" . "exercism")
       :desc "Submit marked files"      "x" #'exercism-dired-submit-marked-files))
#+end_src
** Clojure
#+BEGIN_SRC emacs-lisp
(add-hook! 'clojure-mode-hook
           #'lsp-deferred
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode)
(add-hook! 'clojurescript-mode-hook
           #'lsp-deferred
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode)
#+END_SRC
** Common Lisp
*** Settings
#+BEGIN_SRC emacs-lisp
(add-hook! 'lisp-mode-hook
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode
           #'company-quickhelp-mode)
(after! sly
  (setq! sly-lisp-implementations
         '((sbcl ("~/programs/bin/ros" "-L" "sbcl" "-Q" "run") :coding-system utf-8-unix)
           (clisp ("~/programs/bin/ros" "-L" "clisp" "-Q" "run"))
           (clozure-cl ("~/programs/bin/ros" "-L" "ccl-bin" "-Q" "run"))
           (cmucl ("~/programs/bin/ros" "-L" "cmu-bin" "-Q" "run"))
           (ecl ("~/programs/bin/ros" "-L" "ecl" "-Q" "run") :coding-system utf-8-unix)
           (abcl ("~/programs/bin/ros" "-L" "abcl-bin" "-Q" "run")))))
(map! :map sly-mrepl-mode-map
      (:g "<C-up>" #'comint-previous-input
       :g "<C-down>" #'comint-next-input))

#+END_SRC
**** Hyperspec lookup
Open CL REPL and execute: ~(ql:quickload "clhs")~, then follow instructions.
~C-c C-d h~ on common lisp directive, and it should open the definition in the default web browser.
#+BEGIN_SRC emacs-lisp
(after! lisp-mode
  (when (file-exists-p "/home/thawes/.roswell/lisp/quicklisp/clhs-use-local.el")
    (load! "/home/thawes/.roswell/lisp/quicklisp/clhs-use-local.el")))
(map! :after sly
      :map lisp-mode-map
      :g "C-c C-d h" #'sly-documentation-lookup)
#+END_SRC
**** Common Lisp Language Server
This is functional, but untested on Doom Emacs, and disabled for now. Most of the functionality for this is given with Sly/Slime.

In order to use, be sure to install the language server first, by running ~ros install cxxxr/cl-lsp~
See also the Github repo [[https://github.com/cxxxr/cl-lsp.git][cl-lsp]].
#+BEGIN_SRC emacs-lisp
;; (add-to-list 'lsp-language-id-configuration '(lisp-mode "lisp"))
;;   (lsp-register-client
;;    (make-lsp-client :new-connection (lsp-stdio-connection "cl-lsp")
;;                     :major-modes '(lisp-mode)
;;                     :server-id 'cl-lsp))
;;   (add-hook 'lisp-mode-hook 'lsp-deferred)
#+END_SRC
** Emacs Lisp
*** Settings
#+BEGIN_SRC emacs-lisp
(after! company
  (add-to-list 'company-backends 'company-elisp))
(add-hook! 'emacs-lisp-mode-hook
           #'eldoc-mode
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode
           #'company-quickhelp-mode)
#+END_SRC
*** Safe-variables
#+begin_src emacs-lisp
(mapc (lambda (cmd) (add-to-list 'safe-local-variable-values cmd))
      '((projectile-project-test-cmd . #'stringp)))
#+end_src
** Fennel
Fennel, a Lisp that compiles to Lua
*** Package
#+begin_src emacs-lisp :tangle packages.el
(package! fennel-mode :recipe
  (:host gitlab :repo "technomancy/fennel-mode")
  :pin "59ab0234") ;; Commit date 2021/4/9
#+end_src
*** Config
TODO: FIXME: There is a conflict between fennel bound keys and Sly.
#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist '("\\.fnl\\'" . fennel-mode))
(add-hook! 'fennel-mode
           #'aggressive-indent-mode
           #'smartparens-global-strict-mode)
#+end_src
** GDScript
** Gerbil Scheme
This is a work in progress, and currently inop.
*** Package
Both Gambit and Gerbil modes are needed. Be sure to install the treadmill server package in order to use treadmill. From the shell, run:
~gxpkg install github.com/thunknyc/gerbil-treadmill~
#+BEGIN_SRC emacs-lisp :tangle no
(package! gambit :recipe
  (:host github
   :repo "gambit/gambit"
   :files ("misc/gambit.el"))
  :pin "baf7de6") ;; This is version 4.9.3

(package! gerbil-mode :recipe
  (:host github
   :repo "vyzo/gerbil"
   :files ("etc/gerbil-mode.el"))
  :pin "4189bec") ;; This is version 0.16

(package! treadmill :recipe
  (:host github
   :repo "thunknyc/emacs-treadmill")
  :pin "271d117") ;; Commit date 2019/1/7
#+END_SRC
*** Config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package! gerbil-mode
  :when (getenv "GERBIL_HOME")
  :mode (("\\.ss\\'"  . gerbil-mode)
         ("\\.pkg\\'" . gerbil-mode))
  :init
  (map! :map comint-mode-map
        (:g "<C-up>" #'comint-previous-input
         :g "<C-down>" #'comint-next-input))
  (setf gerbil-home (getenv "GERBIL_HOME"))
  :config
  (use-package! gambit
    :config
    (setf gambit-home (getenv "GAMBIT_HOME"))
    (add-hook! 'inferior-scheme-mode-hook #'gambit-inferior-mode))
  (setq! gerbil-program-name (concat gerbil-home "/bin/gxi"))
  (let ((tags (locate-dominating-file default-directory "TAGS")))
    (when tags (visit-tags-table tags)))
  (visit-tags-table (concat gerbil-home "/src/TAGS")))

#+END_SRC
** Groovy
Just for Jenkinsfile support
*** package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! groovy-mode :recipe
  (:host github :repo "Groovy-Emacs-Modes/groovy-emacs-modes")
  :pin "99eaf70") ;; Commit date 2021/5/9
#+END_SRC

** HTML
*** Impatience mode for realtime editing of html
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! web-mode :recipe
  (:host github :repo "fxbois/web-mode")
  :pin "8ef4793") ;; Commit date 2021/1/31
;;(package! impatient-mode :recipe '(:host github :repo "skeeto/impatient-mode"))
(package! impatient-mode :recipe
  (:host github :repo "skeeto/impatient-mode")
  :pin "cbddfd5") ;; Commit date 2020/7/23
#+END_SRC
**** Hooks
#+BEGIN_SRC emacs-lisp
(use-package! web-mode
  :mode (("\\.html"        . web-mode)
         ("\\.htm"         . web-mode)
         ("\\.mustache\\'" . web-mode)
         ("\\.phtml\\'"    . web-mode)
         ("\\.as[cp]x\\'"  . web-mode))
  :config
  (setq! web-mode-markup-indent-offset 2)
  (setq! web-mode-css-indent-offset 2)
  (setq! web-mode-code-indent-offset 2)
  (setq! web-mode-comment-style 2)
  ;;(setq! web-mode-enable-auto-indentation nil)
  (setq! web-mode-enable-css-colorization t)
  (setq! web-mode-enable-block-face t)
  (setq! web-mode-enable-comment-keywords t)
  (setq! web-mode-enable-heredoc-fontification t)

  (setq! web-mode-enable-auto-quoting t)
  (setq! web-mode-enable-auto-pairing t)
  (setq! web-mode-tag-auto-close-style 2))

(add-hook! 'web-mode-hook #'impatient-mode)
(add-hook! 'css-mode-hook #'impatient-mode)
#+END_SRC
** Java
** Javascript
*** Websocket
Needed by Indium
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! websocket :recipe
  (:host github :repo "ahyatt/emacs-websocket")
  :pin "34e1112") ;; Commit date 2021/1/9  Old: :pin "491a60b"
#+END_SRC
*** Indium
**** Package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! indium :recipe
  '(:host github :repo "NicolasPetton/Indium")
  :pin "8499e15") ;; Commit date 2021/3/9
#+END_SRC
*** Node-REPL
**** Default hooks
#+begin_src emacs-lisp
(add-hook! 'js2-mode-hook
           #'aggressive-indent-mode
           #'smartparens-strict-mode)
#+end_src
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! nodejs-repl :recipe
  (:host github :repo "abicky/nodejs-repl.el")
  :pin "3b84105") ;; Commit date 2020/8/2
#+end_src
**** Config
#+begin_src emacs-lisp
(map! :map js2-mode-map
      :prefix "C-x"
      :g "C-e" #'nodejs-repl-send-last-expression)
(map! :map js2-mode-map
      :prefix "C-c"
      :g "C-j" #'nodejs-repl-send-line
      :g "C-r" #'nodejs-repl-send-region
      :g "C-c" #'nodejs-repl-send-buffer
      :g "C-k" #'nodejs-repl-load-file
      :g "C-z" #'nodejs-repl-switch-to-repl)
#+end_src
*** Safe-variables
#+begin_src emacs-lisp
(mapc (lambda (cmd) (add-to-list 'safe-local-variable-values cmd))
      '((projectile-project-configure-cmd . "npm install")
        (projectile-project-test-cmd . "npm run test")
        (projectile-project-test-cmd . "npm test")))
#+end_src
** Jenkinsfile
*** package
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! jenkinsfile-mode :recipe
  (:host github :repo "john2x/jenkinsfile-mode")
  :pin "65bf392") ;; Commit date 2020/9/29
#+END_SRC
*** config
#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/Jenkinsfile" . jenkinsfile-mode))
(add-to-list 'auto-mode-alist '("/jenkinsfile" . jenkinsfile-mode))
(add-hook! 'jenkinsfile-mode (lambda () (setq! groovy-indent-offset 2)))
#+END_SRC
** Lua
*** Love2d Minor-mode
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! love-minor-mode :recipe
  (:host github :repo "ejmr/love-minor-mode")
  :pin "3ca8f34") ;; Commit date 2017/7/27
#+end_src
**** Config
#+begin_src emacs-lisp
(add-hook! 'lua-mode-hook #'love-minor-mode)
#+end_src
** Markdown
*** Impatient mode for realtime editing of markdown
#+BEGIN_SRC emacs-lisp
(defun markdown-html-filter (buffer)
  (princ (with-current-buffer buffer
           (format "<!DOCTYPE html><html><title>Impatient Markdown</title><xmp theme=\"united\" style=\"display:none;\"> %s  </xmp><script src=\"http://strapdownjs.com/v/0.2/strapdown.js\"></script></html>" (buffer-substring-no-properties (point-min) (point-max))))
         (current-buffer)))
(add-hook! 'markdown-mode-hook #'impatient-mode
  (lambda () (imp-set-user-filter #'markdown-html-filter)))
#+END_SRC

** Python
*** Elpy
**** Package
I have found anaconda-mode to be inferior ro elpy.
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! anaconda-mode :ignore t)
(package! elpy :recipe
  (:host github :repo "jorgenschaefer/elpy")
  :pin "2203597") ;; Commit date 2021/3/28
#+END_SRC
**** Config
#+begin_src emacs-lisp
(after! python
  (elpy-enable))
#+end_src
*** Auto-virtualenv
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! auto-virtualenv :recipe
  (:host github :repo "marcwebbie/auto-virtualenv")
  :pin "214604e") ;; Commit date 2020/7/29
#+end_src
**** Config
#+begin_src emacs-lisp
(add-hook! 'python-mode-hook #'auto-virtualenv-set-virtualenv)
#+end_src
*** Pydoc
**** Package
#+begin_src emacs-lisp :tangle packages.el
(package! pydoc :recipe
  (:host github :repo "statmobile/pydoc")
  :pin "4459aa1");; Commit date 2020/10/30
#+end_src
**** Config
#+begin_src emacs-lisp
(setq! elpy-rpc-virtualenv-path 'current)
(map! :map 'python-mode-map
      :g "C-c C-h" #'pydoc-at-point)
#+end_src
*** Python LSP
#+begin_src emacs-lisp
(add-hook! 'python-mode-hook
           #'lsp-deferred)
#+end_src
*** Python REPL
#+begin_src emacs-lisp
(after! python
  (when (executable-find "ipython")
    (setq! python-shell-interpreter "ipython"
           python-shell-interpreter-interactive-arg "-i"
           python-shell-interpreter-args "-i --no-ignore-cwd --no-banner"
           python-shell-prompt-regexp "In \[[0-9]+\]: "
           python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: ")))
#+end_src

** Racket
*** Package
#+begin_src emacs-lisp :tangle packages.el
(package! racket-mode :recipe
  (:host github :repo "greghendershott/racket-mode")
  :pin "abd59fd") ;; Commit date 2021/5/17
#+end_src
*** Config
#+begin_src emacs-lisp
(add-hook! 'racket-mode-hook
           #'smartparens-strict-mode
           #'aggressive-indent-mode
           #'lisp-extra-font-lock-mode
           #'company-mode)
#+end_src
** Yaml
#+begin_src emacs-lisp
(add-hook! yaml-mode-hook
  (lambda ()
    (prettify-symbols-mode -1)))
#+end_src
* Scripts
** FreeBSD Server Script
#+begin_src shell :shebang "#!/bin/sh" :tangle scripts/emacsd
# PROVIDE: emacsd
# REQUIRE: login # after login

# Emacs daemon
#
# Define emacsd_user and emacd_socket in your /etc/rc.conf file
. /etc/rc.subr

name="emacsd"
rcvar=emacsd_enable

start_cmd="${name}_start"
stop_cmd="${name}_stop"
load_rc_config $name
: ${emacsd_enable:=no}
: ${_msg="Emacs daemon started."}

emacsd_start()
{
    su ${emacsd_user:=nobody} -c "env HOME=/home/alex /usr/local/bin/emacs --daemon=${emacsd_socket:=server}"
}
emacsd_stop()
{
    su ${emacsd_user:nobody} -c "/usr/local/bin/emacsclient --socket ${emacsd_socket:=server} --eval \"(kill-emacs)\""
}
run_rc_command "$1"
#+end_src
* Pending Packages
These are packages I find cool, and might use in the future. I place them here so I can easily find them in the future.
** Aweshell
*** Package
From the make of multi-term, this is eshell on steroids with multi-eshell capability
#+begin_src emacs-lisp :tangle no
(package! aweshell :recipe (:host github :repo "manateelazycat/aweshell")
  :pin "31004dd") ;;Commit date 2020/6/23
#+end_src
*** Config
Details found [[https://github.com/manateelazycat/aweshell][here]].
** Selectrum
A smart replacement for ivy, helm, and ido. You'll need to disable ivy in your init.el before using this. You'll probably have to remap many keys as well. More details found [[https://github.com/raxod502/selectrum][here]].
*** Package
#+begin_src emacs-lisp :tangle no
(package! selectrum :recipe
  (:host github :repo "raxod502/selectrum") :pin "909f614") ;;Commit date 2021/5/17
#+end_src
** Purpose
Once upon a time, I worked on some parts of a large project. I found myself using all kinds of buffers - python files, python interpreter, bash terminal, grep, dired, ibuffer. When I navigated the code, Emacs opened all sorts of buffers in all sorts of windows, and when I finally discovered what variable or function I needed, the window layout was messed up and I had to look for the original file I was working on.
What I was missing was a way to limit which buffers can be displayed in which windows. E2WM helped me somewhat, but wasn't flexible enough. Enter Purpose.

What Purpose does, is assign a purpose to each window and each buffer. This way, any window can display only a certain kind of buffers. Also, Purpose lets the user decide which windows can be used for any purpose, and which windows should stick to one purpose.
What this all should mean, if Purpose is successful, is less time spent fighting Emacs over the window layout and where to display buffers, a pleasant user experience and more time for fun or important work.

Purpose is not meant to be as extensive as E2WM. It has three main goals:

1. provide an easy and reliable way for the user to maintain a consistent window layout
2. provide a framework for extensions that make use of the window layout
3. hopefully, be a step towards IDE-like packages in the future (seriously)

More [[https://github.com/bmag/emacs-purpose/wiki][here]].
#+begin_src emacs-lisp :tangle no
(package! purpose :recipe
  (:host github :repo "bmag/emacs-purpose")
  :pin "1a55629") ;; Commit date 2021/4/23
#+end_src
