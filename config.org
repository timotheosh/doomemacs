#+title: Emacs Config (Doom Emacs)
#+author: Tim Hawes
#+property: header-args :tangle yes :mkdirp yes

Place your private configuration here! Remember, you do not need to run ~doom sync~ after modifying this file!
* Packages File
Create the packages.el file.
#+BEGIN_SRC emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el
#+END_SRC

* Heading
#+BEGIN_SRC emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

#+END_SRC
* Identification
Some functionality uses this to identify you, e.g. GPG configuration, email clients, file templates and snippets.
#+BEGIN_SRC emacs-lisp
(setq user-full-name "Tim Hawes"
      user-mail-address "trhawes@gmail.com")
#+END_SRC
* Fonts
Doom exposes five (optional) variables for controlling fonts in Doom. Here are the three important ones:
- ~doom-font~
- ~doom-variable-pitch-font~
- ~doom-big-font~ -- used for ~doom-big-font-mode~ Use this for presentations or streaming.
They all accept either a font-spec, font string ("Input Mono-12"), or xlfd font string. You generally only need these two:
#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "monospace" :size 14))
#+END_SRC
* Theme
There are two ways to load a theme. Both assume the theme is installed and available. You can either set ~doom-theme~ or manually load a theme with the ~load-theme~ function. This is the default:
#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-one)
#+END_SRC
* Line number style
This determines the style of line numbers in effect. If set to `nil', line numbers are disabled. For relative line numbers, set this to `relative'.
#+BEGIN_SRC emacs-lisp
(setq display-line-numbers-type t)
#+END_SRC
* Additional Macros
Here are some additional functions/macros that could help you configure Doom:
- ~load!~ for loading external *.el files relative to this one
- ~use-package~ for configuring packages
- ~after!~ for running code after a package has loaded
- ~add-load-path!~ for adding directories to the `load-path', relative to this file. Emacs searches the ~load-path~ when you load packages with ~require~ or ~use-package~.
- ~map!~ for binding new keys

To get information about any of these functions/macros, move the cursor over the highlighted symbol at press 'K' (non-evil users must press 'C-c g k'). This will open documentation for it, including demos of how they are used.

You can also try 'gd' (or 'C-c g d') to jump to their definition and see how they are implemented.
* Keys
** Tabs
#+BEGIN_SRC emacs-lisp
(map! :map projectile-mode-map
      :g "<f4>" #'projectile-find-file)

(map! :map centaur-tabs-mode-map
      :g "C-<prior>" #'centaur-tabs-backward
      :g "C-<next>" #'centaur-tabs-forward)
#+END_SRC
** Return counsel-find-file back to its default behavior
#+BEGIN_SRC emacs-lisp
(map! :map ivy-minibuffer-map
      :g "TAB" #'ivy-partial-or-done)
#+END_SRC
* Emacs Frame Manager
The purpose of this modules is managing Emacs windows in an environment without using EXWM. This will offer functions an emacsclient can run conditioned on the current state of the window, and fast terminal access within Emacs. This will work with X11, not sure what the implications are for Cocoa or Windows.
** Setup
We'll need to load this file.
#+BEGIN_SRC emacs-lisp
(load! "+emacs-frame-manager")
#+END_SRC
Setup the heading for this file
#+BEGIN_SRC emacs-lisp :tangle +emacs-frame-manager.el
;; Copyright (C) 2020 Tim Hawes <thawes@gmail.com>
;; Maintainer: Tim Hawes
;; Created: 15 May 2020
;; Version: 0.01
#+END_SRC

** Frame Names
First, we set up unique names for the X Window names, so we can easily reference these windows in an X Window environment. The names have random numbers, to make them easier to isolate among many windows in an X environment.
   #+BEGIN_SRC emacs-lisp :tangle +emacs-frame-manager.el
(defvar efm/frame-name "emacs-frame-manager998")
(defvar efm/shell-name "emacs-frame-manager336")
(defvar efm/org-name "emacs-frame-manager920")
   #+END_SRC
** Extra frames
When emacs runs in daemon mode under systemd, emacsclient can, and sometimes will, create extra frames when you execute a command with emacsclient that does not need a frame, before any frames have been opened, and then execute emacsclient with a new frame. We keep track of legitimate frames, so we can just delete the unneeded frames. If you add new frames above that you intend to use, be sure to add them to this list, so they do not get inadvertently deleted.
   #+BEGIN_SRC emacs-lisp :tangle +emacs-frame-manager.el
(defvar efm/legit-frames (list efm/frame-name efm/shell-name efm/org-name "F1"))
   #+END_SRC
- Now the utility functions
  #+BEGIN_SRC emacs-lisp :tangle +emacs-frame-manager.el
(defun efm/list-illegite-frames ()
  "Lists visible illegitimate frames. Essentially all frames not in the efm/legit-frames list and is visible."
  (remove-if
   (lambda (x)
     (seq-find (lambda (y)
                 (string= y
                          (frame-parameter x 'name))) efm/legit-frames))
   (remove-if-not 'frame-visible-p (frame-list))))

(defun efm/kill-illegite-frames ()
  "Deletes the extra visible frames."
  (dolist (buf (efm/list-illegite-frames))
    (delete-frame buf)))
  #+END_SRC
** Frame management
Utility functions for frame management. These find frames, suspend frames, raise frames and maximize frames.
#+BEGIN_SRC emacs-lisp :tangle +emacs-frame-manager.el

(defun efm/find-frame (frame-name)
  "Returns a list of frames with frame-name."
  (remove-if-not
   (lambda (x)
     (string= (frame-parameter x 'name) frame-name))
   (frame-list)))

(defun efm/maximized-p (frame)
  "Returns true if frame is maximized or fullboth."
  (cdr (assoc 'fullscreen (frame-parameters frame))))

(defun efm/create-frame (frame-name frame-title)
  "Creates a maximized frame, raised and in focus."
  (make-frame-on-display (getenv "DISPLAY") `((name . ,frame-name)
                                              (title . ,frame-title)
                                              (fullscreen . maximized)
                                              (window-system . x)))
  (let ((frame (car (efm/find-frame name))))
    (frame-focus frame)
    (x-focus-frame frame)))

(defun efm/raise-frame (frame)
  "Raises a frame and puts it in focus."
  (raise-frame frame)
  (select-frame frame)
  (x-focus-frame frame))

(defun efm/frame-focus-maximize (frame &optional command)
  "Raise, focus, and maximize a frame."
  (efm/raise-frame frame)
  (modify-frame-parameters frame '((fullscreen . maximized)))
  (when command
    (eval (list (intern command)))))

(defun efm/start-client-with-command (name title &optional command skip-taskbar)
  "Create a new frame, executing command."
  (efm/create-frame name title)
  (if command
      (eval (list (intern command)))
    (switch-to-buffer "*dashboard*"))
  (when skip-taskbar
    (modify-frame-parameters (car (efm/find-frame name)) '((skip-taskbar t)
                                                           (undecorated t)))))

(defun efm/raise-or-start (name title &optional command toggle skip-taskbar)
  "If frame with name does not exist, create it, otherwise raise, focus and maximize the existing frame."
  (let ((frame (car (efm/find-frame name))))
    (if frame
        (if (and (frame-focus-state frame)
                 (efm/maximized-p frame)
                 (or (and (null command) (null toggle))
                     (and (not (null command)) (not (null toggle)))))
            (progn (select-frame frame)
                   (suspend-frame))
          (efm/frame-focus-maximize frame command))
      (efm/start-client-with-command name title command skip-taskbar))))

#+END_SRC
* Email
Use Gmail in gnus
** Settings
#+BEGIN_SRC emacs-lisp :tangle +email.el

#+END_SRC
** Load Email settings
#+BEGIN_SRC emacs-lisp
(load! "+email")
#+END_SRC
* Dired
** Packages
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! ranger)
#+END_SRC
** Settings
#+BEGIN_SRC emacs-lisp :tangle +dired
(add-hook 'dired-mode-hook (lambda ()
                             (setq dired-hide-details-mode t)
                             (setq ranger-override-dired-mode t)))
#+END_SRC
** Load Dired settings
#+BEGIN_SRC emacs-lisp
(load! "+dired")
#+END_SRC
* Eshell
** Packages
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! esh-help)
(package! multi-eshell)
(package! eshell-prompt-extras)
#+END_SRC
** Settings
*** Custom magit commands in eshell
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(defun eshell/mgit (&rest args)
  "Using magit in eshell"
  (eshell-eval-using-options
   "mgit" args
   '((?s "status" nil status "Show git status for repo.")
     (?l "log" nil log "Show git log for all branches")
     (nil "help" nil nil "Show this usage information")
     :show-usage)
   (eshell-do-eval
    (eshell-parse-command
     (cond
      (status "magit-status")
      (log "magit-log-all-branches")))
    t)))
#+END_SRC
*** Custom dpkg commands in eshell
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(defun eshell/deb (&rest args)
  "deb command for eshell"
  (eshell-eval-using-options
   "deb" args
   '((?f "find" t find "list available packages matching a pattern")
     (?i "installed" t installed "list installed debs matching a pattern")
     (?l "list-files" t list-files "list files of a package")
     (?s "show" t show "show an available package")
     (?v "version" t version "show the version of an installed package")
     (?w "where" t where "find the package containing the given file")
     (nil "help" nil nil "show this usage information")
     :show-usage)
   (eshell-do-eval
    (eshell-parse-command
     (cond
      (find
       (format "apt-cache search %s" find))
      (installed
       (format "dlocate -l %s | grep '^.i'" installed))
      (list-files
       (format "dlocate -L %s | sort" list-files))
      (show
       (format "apt-cache show %s" show))
      (version
       (format "dlocate -s %s | egrep '^(Package|Status|Version):'" version))
      (where
       (format "dlocate %s" where))))
    t)))
#+END_SRC
*** Eshell history settings
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(setq eshell-history-size 1024)

(load "em-hist")           ; So the history vars are defined
(if (boundp 'eshell-save-history-on-exit)
    (setq eshell-save-history-on-exit t)) ; Don't ask, just save
                                        ;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
(if (boundp 'eshell-ask-to-save-history)
    (setq eshell-ask-to-save-history 'always)) ; For older(?) version
                                        ;(message "eshell-ask-to-save-history is %s" eshell-ask-to-save-history)
#+END_SRC
*** Tramp settings for eshell
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(require 'esh-module) ;; load tramp functions into eshell
#+END_SRC
*** Custom prompt
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(use-package! eshell-prompt-extras
  :config
  ;; for virtualenvwrapper stuff
  (with-eval-after-load "esh-opt"
    (require 'virtualenvwrapper)
    (venv-initialize-eshell)
    (autoload 'epe-theme-lambda "eshell-prompt-extras")
    (setq eshell-highlight-prompt nil
          eshell-prompt-function 'epe-theme-lambda
          eshell-prompt-regexp "^[^#\nλ]*[#λ] "
          epe-show-python-info t
          epe-path-style 'single)))
#+END_SRC
** Modules
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(add-to-list 'eshell-modules-list 'eshell-tramp 'esh-opt)
#+END_SRC
** Preferred functions and variables
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(setq eshell-prefer-lisp-functions t)
(setq eshell-prefer-lisp-variables t)
#+END_SRC
** Password caching
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
(setq password-cache t) ; enable password caching
(setq password-cache-expiry 300) ; for 5 minutes (time in secs)
#+END_SRC
** Progress bar for apt in minibuffer
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
;; Progress bars, like apt in the status/echo area
(advice-add
 'ansi-color-apply-on-region
 :before 'ora-ansi-color-apply-on-region)

(defun ora-ansi-color-apply-on-region (begin end)
  "Fix progress bars for e.g. apt(8).
Display progress in the mode line instead."
  (let ((end-marker (copy-marker end))
        mb)
    (save-excursion
      (goto-char (copy-marker begin))
      (while (re-search-forward "\0337" end-marker t)
        (setq mb (match-beginning 0))
        (when (re-search-forward "\0338" end-marker t)
          (ora-apt-progress-message
           (substring-no-properties
            (delete-and-extract-region mb (point))
            2 -2)))))))

(defun ora-apt-progress-message (progress)
  (message
   (replace-regexp-in-string
    "%" "%%"
    (ansi-color-apply progress))))
#+END_SRC
** Visual commands
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
;; Visual commands
;; defaults are ("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm")
(setq eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx" "ncftp" "pine" "tin" "trn" "elm"))
(dolist (cmd '("tmux" "aptitude" "aws-shell" "neofetch" "htop"))
  (add-to-list 'eshell-visual-commands cmd))
#+END_SRC
** Use Emacs completion package for Eshell
#+BEGIN_SRC emacs-lisp :tangle +eshell.el
;; Uses the default Emacs completion package for tab-complete in eshell.
(add-hook 'eshell-mode-hook
          (lambda ()
            (define-key eshell-mode-map (kbd "<tab>")
              (lambda () (interactive) (pcomplete-std-complete)))))
#+END_SRC
** Load Eshell Settings
#+BEGIN_SRC emacs-lisp
(load! "+eshell.el")
#+END_SRC
* Org-mode Files
If you use `org' and don't want your org files in the default location below, change `org-directory'. It must be set before org loads!
#+BEGIN_SRC emacs-lisp
(setq org-directory "~/org/")
#+END_SRC
* Org-mode
#+BEGIN_SRC emacs-lisp
(setq org-startup-folded t)
#+END_SRC
* Programming Languages
** Python
*** Packages
#+BEGIN_SRC emacs-lisp :tangle packages.el
(package! virtualenvwrapper)
#+END_SRC
*** Modules
#+BEGIN_SRC emacs-lisp :tangle modules/lang/python/config.el
;;; lang/python/config.el -*- lexical-binding: t; -*-
(setq python-shell-interpreter "ipython")
;; Make available immediately
(use-package! virtualenvwrapper
  :config
  (venv-initialize-interactive-shells) ;; if you want interactive shell support
  (venv-initialize-eshell) ;; if you want eshell support
  ;; note that setting `venv-location` is not necessary if you
  ;; use the default location (`~/.virtualenvs`), or if the
  ;; the environment variable `WORKON_HOME` points to the right place
  (setq venv-location "/home/thawes/.virtualenvs/"))
#+END_SRC
